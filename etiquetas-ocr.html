<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Etiquetas PDF</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css?v=20240826">
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
  <script src="expedicao-notifier.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <style>
    .progress-bar-bg {
      background: linear-gradient(90deg, #cfd9df 0%, #e2ebf0 100%);
      border-radius: 9999px;
      height: 1.5rem;
      overflow: hidden;
      box-shadow: 0 2px 16px rgba(0,0,0,0.08);
    }
    .progress-bar-fill {
      background: linear-gradient(90deg, #06B6D4 0%, #3B82F6 100%);
      height: 100%;
      border-radius: 9999px 0 0 9999px;
      transition: width 0.3s cubic-bezier(.4,0,.2,1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 600;
      font-size: 0.875rem;
      background-size: 200% 100%;
      animation: progress-animation 2s linear infinite;
    }
    @keyframes progress-animation {
      0% { background-position: 0% 0; }
      100% { background-position: -200% 0; }
    }
    .progress-bar-fill.progress-complete {
      background: linear-gradient(90deg, #16A34A 0%, #22C55E 100%);
      animation: none;
    }
    .progress-bar-fill.progress-error {
      background: linear-gradient(90deg, #EF4444 0%, #F97316 100%);
      animation: none;
    }
    #timerText {
      font-size: 0.875rem;
      color: #374151;
      font-weight: 500;
    }
    #status {
      min-height: 2rem;
    }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(17, 24, 39, 0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 9999;
    }
    .modal-content {
      background: #ffffff;
      border-radius: 0.75rem;
      width: 100%;
      max-width: 28rem;
      padding: 1.75rem 1.5rem;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.25);
      border: 2px solid transparent;
      transition: all 0.3s ease;
    }
    .modal-content.modal-success {
      background: #ecfdf5;
      border-color: #34d399;
      color: #065f46;
    }
    .modal-content.modal-error {
      background: #fef2f2;
      border-color: #f87171;
      color: #991b1b;
    }
    .processing-alert {
      font-size: 0.9rem;
      font-weight: 500;
      color: #1f2937;
    }
    .modal-content.modal-success .processing-alert {
      color: #047857;
    }
    .modal-content.modal-error .processing-alert {
      color: #b91c1c;
    }
    .modal-close {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.6rem 1.25rem;
      border-radius: 9999px;
      font-weight: 600;
      background: linear-gradient(90deg, #1d4ed8 0%, #2563eb 100%);
      color: #ffffff;
      transition: filter 0.2s ease;
    }
    .modal-close:hover {
      filter: brightness(1.05);
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen">
  <div class="app-container">
  <div id="sidebar-container"></div>
  <div id="navbar-container"></div>
  <div class="max-w-xl w-full mx-auto p-4">
    <h1 class="text-4xl font-bold text-center mb-6 flex items-center justify-center gap-2">
      <i class="fa-solid fa-barcode"></i>
      ETIQUETAS PDF
    </h1>

    <div class="mb-4">
      <p class="text-sm font-medium text-gray-700 mb-1">Seus Gestores</p>
      <input type="text" id="gestoresEmails" placeholder="E-mails do gestor de expedi√ß√£o (separados por v√≠rgula)" class="w-full border border-gray-300 rounded-lg p-2" />
    </div>

    <div class="mb-6">
      <label for="pdfInput" class="block cursor-pointer">
        <div class="w-full p-6 border-2 border-dashed border-gray-300 rounded-lg text-center bg-white hover:bg-gray-50">
          <i class="fa-solid fa-cloud-arrow-up text-3xl text-gray-400 mb-2"></i>
          <p class="text-gray-600">Arrastar e soltar ou clicar para fazer upload</p>
        </div>
      </label>
      <input type="file" id="pdfInput" accept="application/pdf" class="hidden" />
    </div>

    <button class="w-full py-3 rounded-lg text-white font-medium bg-gradient-to-r from-teal-500 to-blue-500 mb-4" onclick="processar()">
      Etiquetas Shopee + lista empacotamento
    </button>
    <button class="w-full py-3 rounded-lg text-white font-medium bg-gradient-to-r from-teal-500 to-blue-500" onclick="processarMercadoLivre()">
      Etiquetas Mercado Livre
    </button>

    <div class="status mt-4 text-blue-700 font-medium" id="status"></div>
    <canvas id="pdfCanvas" class="mt-8 mx-auto border rounded-lg shadow" style="display:none;max-width:100%;box-shadow:0 2px 16px rgba(0,0,0,0.04);"></canvas>
    <div class="flex justify-center mt-8">
      <span class="text-xs text-gray-500">Desenvolvido por Matheus Ferraretto &nbsp;¬∑&nbsp; <i class="fa-solid fa-robot"></i></span>
    </div>
  </div>

  <div id="gestorModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
    <div class="bg-white w-full max-w-md p-4 rounded shadow-lg">
      <h2 class="text-lg font-semibold mb-2">Enviar arquivo para qual gestor?</h2>
      <select id="gestorSelect" class="form-control mb-4"></select>
      <div class="flex justify-end gap-2">
        <button id="gestorCancel" class="btn btn-secondary">Cancelar</button>
        <button id="gestorConfirm" class="btn btn-primary">Confirmar</button>
      </div>
    </div>
  </div>

  <div id="processingModal" class="modal-overlay hidden">
    <div id="processingModalContent" class="modal-content">
      <div class="flex items-start gap-3 mb-3">
        <div class="text-3xl text-blue-500" id="processingIconWrapper">
          <i id="processingIcon" class="fa-solid fa-gear fa-spin"></i>
        </div>
        <div>
          <h3 id="processingTitle" class="text-xl font-semibold text-gray-800">Processando etiquetas</h3>
          <p id="processingAlertText" class="processing-alert mt-1">Por favor, n√£o feche a p√°gina durante o processamento.</p>
        </div>
      </div>
      <div class="progress-bar-bg" id="progressBar" style="display:none;">
        <div class="progress-bar-fill" id="progressFill" style="width:0%;">
          <span id="progressText" class="w-full text-center"></span>
        </div>
      </div>
      <div id="timerText" class="text-center text-sm text-gray-700 mt-3"></div>
      <div class="flex justify-end mt-6">
        <button id="processingClose" class="modal-close hidden">Fechar</button>
      </div>
    </div>
  </div>

      <script type="module">
    import { firebaseConfig } from './firebase-config.js';

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

 if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    const db = firebase.firestore();
    const storage = firebase.storage();
    let currentUser = null;
    let responsavelExpedicaoUid = null;
    let horariosEtiquetas = [];
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const timerText = document.getElementById('timerText');
    const processingModal = document.getElementById('processingModal');
    const processingModalContent = document.getElementById('processingModalContent');
    const processingTitle = document.getElementById('processingTitle');
    const processingAlertText = document.getElementById('processingAlertText');
    const processingClose = document.getElementById('processingClose');
    const processingIcon = document.getElementById('processingIcon');
    const processingIconWrapper = document.getElementById('processingIconWrapper');

    function openProcessingModal(title = 'Processando etiquetas') {
      processingModal.classList.remove('hidden');
      processingModalContent.classList.remove('modal-success', 'modal-error');
      processingTitle.textContent = title;
      processingAlertText.textContent = 'Por favor, n√£o feche a p√°gina durante o processamento.';
      progressBar.style.display = 'block';
      progressFill.style.width = '0%';
      progressFill.classList.remove('progress-complete', 'progress-error');
      progressText.textContent = '';
      timerText.textContent = '';
      processingClose.classList.add('hidden');
      processingIcon.className = 'fa-solid fa-gear fa-spin';
      processingIconWrapper.classList.remove('text-green-500', 'text-red-500');
      processingIconWrapper.classList.add('text-blue-500');
    }

    function markProcessingSuccess(message = 'Arquivo salvo com sucesso! Voc√™ j√° pode fechar esta janela.') {
      processingModalContent.classList.remove('modal-error');
      processingModalContent.classList.add('modal-success');
      processingTitle.textContent = 'Processamento conclu√≠do';
      processingAlertText.textContent = message;
      progressFill.classList.add('progress-complete');
      processingClose.classList.remove('hidden');
      processingIcon.className = 'fa-solid fa-circle-check';
      processingIconWrapper.classList.remove('text-blue-500', 'text-red-500');
      processingIconWrapper.classList.add('text-green-500');
    }

    function markProcessingError(message = 'N√£o foi poss√≠vel concluir o processamento. Tente novamente.') {
      processingModalContent.classList.remove('modal-success');
      processingModalContent.classList.add('modal-error');
      processingTitle.textContent = 'Ocorreu um erro';
      processingAlertText.textContent = message;
      progressFill.classList.add('progress-error');
      processingClose.classList.remove('hidden');
      processingIcon.className = 'fa-solid fa-triangle-exclamation';
      processingIconWrapper.classList.remove('text-blue-500', 'text-green-500');
      processingIconWrapper.classList.add('text-red-500');
    }

    function closeProcessingModal() {
      processingModal.classList.add('hidden');
      progressBar.style.display = 'none';
    }

    processingClose.addEventListener('click', closeProcessingModal);
    processingModal.addEventListener('click', event => {
      if (event.target === processingModal && !processingClose.classList.contains('hidden')) {
        closeProcessingModal();
      }
    });

    function escolherGestorEmail(emails) {
      return new Promise(resolve => {
        if (!emails || !emails.length) return resolve([]);
        if (emails.length === 1) return resolve([emails[0]]);

        const modal = document.getElementById('gestorModal');
        const select = document.getElementById('gestorSelect');
        const confirmBtn = document.getElementById('gestorConfirm');
        const cancelBtn = document.getElementById('gestorCancel');

        select.innerHTML = '';
        emails.forEach(email => {
          const opt = document.createElement('option');
          opt.value = email;
          opt.textContent = email;
          select.appendChild(opt);
        });

        function close(value) {
          modal.classList.add('hidden');
          confirmBtn.removeEventListener('click', onConfirm);
          cancelBtn.removeEventListener('click', onCancel);
          modal.removeEventListener('click', onBackdrop);
          resolve([value]);
        }

        function onConfirm() { close(select.value || emails[0]); }
        function onCancel() { close(emails[0]); }
        function onBackdrop(e) { if (e.target === modal) close(emails[0]); }

        confirmBtn.addEventListener('click', onConfirm);
        cancelBtn.addEventListener('click', onCancel);
        modal.addEventListener('click', onBackdrop);

        modal.classList.remove('hidden');
      });
    }
firebase.auth().onAuthStateChanged(async u => {
      currentUser = u;
      if (!u) return;
      try {
        const doc = await db.collection('uid').doc(u.uid).get();
        const data = doc.data() || {};
        const emails = data.gestoresExpedicaoEmails || data.responsavelExpedicaoEmail || '';
        document.getElementById('gestoresEmails').value = Array.isArray(emails) ? emails.join(', ') : emails;
        const respEmail = Array.isArray(data.gestoresExpedicaoEmails) ? data.gestoresExpedicaoEmails[0] : data.responsavelExpedicaoEmail;
        if (respEmail) {
          const snap = await db.collection('uid').where('email', '==', respEmail).limit(1).get();
          if (!snap.empty) responsavelExpedicaoUid = snap.docs[0].id;
          await carregarHorarios();
        }
      } catch (err) {
        console.error('Erro ao carregar gestor de expedi√ß√£o:', err);
      }
    });
    
    function showMessage(text) {
      const messageBox = document.getElementById("messageBox");
      const messageText = document.getElementById("messageText");
      messageText.textContent = text;
      messageBox.style.display = "block";
    }

    async function carregarHorarios() {
      if (!responsavelExpedicaoUid) return;
      try {
        const doc = await db.collection('uid').doc(responsavelExpedicaoUid).get();
        const data = doc.data() || {};
        horariosEtiquetas = data.horariosEtiquetas || [];
      } catch (e) {
        console.error('Erro ao carregar hor√°rios:', e);
      }
    }

    function foraDoHorario() {
      if (!horariosEtiquetas.length) return false;
      const now = new Date();
      return !horariosEtiquetas.some(h => {
        if (!h.inicio || !h.fim) return false;
        const [ih, im] = h.inicio.split(':').map(Number);
        const [fh, fm] = h.fim.split(':').map(Number);
        const start = new Date(now);
        start.setHours(ih, im, 0, 0);
        const end = new Date(now);
        end.setHours(fh, fm, 0, 0);
        return now >= start && now <= end;
      });
    }

    async function extractSkuQuantitiesFromCanvas(canvas, info) {
      const ctxInfo = info || {};
      console.groupCollapsed('[OCR] Iniciando reconhecimento', ctxInfo);
      console.time('[OCR] tempo');
      const { data } = await Tesseract.recognize(canvas, 'por+eng');
      const text = data?.text || '';
      console.timeEnd('[OCR] tempo');
      console.log('[OCR] Dimens√µes canvas', { width: canvas.width, height: canvas.height });
      console.log('[OCR] Texto bruto');
      console.log(text);

      const items = [];
      // 1) Padr√£o principal: SKU ... (QTD|QUANTIDADE|QTY) ... n√∫mero
      //    Permite + no SKU (ex.: T6+P4)
      const regex = /SKU\s*[:\-]?\s*([A-Z0-9\.\+_\-\/]+).*?(?:QTD|QUANTIDADE|QTY|QDE)\s*[:\-]?\s*(\d{1,3})/gis;
      let match;
      while ((match = regex.exec(text)) !== null) {
        items.push({ sku: (match[1]||'').trim(), quantidade: parseInt(match[2], 10) || 0 });
      }

      // 2) Padr√£o alternativo: SKU ... x 2
      if (items.length === 0) {
        const alt = /SKU\s*[:\-]?\s*([A-Z0-9\.\+_\-\/]+)\s*[xX*]\s*(\d{1,3})/gis;
        while ((match = alt.exec(text)) !== null) {
          items.push({ sku: (match[1]||'').trim(), quantidade: parseInt(match[2], 10) || 0 });
        }
      }

      // 3) Heur√≠stica linha-a-linha (SKU na linha N, quantidade na N+1)
      if (items.length === 0) {
        const lines = text.split(/\n/).map(l => l.trim()).filter(Boolean);
        console.log('[OCR] Linhas normalizadas', lines);
        for (let i = 0; i < lines.length; i++) {
          const skuMatch = lines[i].match(/SKU\s*[:\-]?\s*([A-Z0-9\.\+_\-\/]+)/i);
          if (skuMatch) {
            const next = (lines[i + 1] || '') + ' ' + (lines[i + 2] || '');
            const qtdMatch = next.match(/(QTD|QUANTIDADE|QTY|QDE)\s*[:\-]?\s*(\d{1,3})/i) || next.match(/[xX*]\s*(\d{1,3})/);
            const qtdVal = qtdMatch ? parseInt(qtdMatch[qtdMatch.length - 1], 10) || 0 : 0;
            items.push({ sku: (skuMatch[1]||'').trim(), quantidade: qtdVal });
          }
        }
      }

      // 4) Heur√≠stica por linha com quantidade no fim
      //    Estruturas vistas no OCR: "1 Artigo ... T6+P4 CILINDROS + ARCO 2" ou "1 Trio de Boleiras TR15 1"
      if (items.length === 0) {
        const lines = text.split(/\n/).map(l => l.trim()).filter(Boolean);
        for (const line of lines) {
          const mQty = line.match(/(.+?)\s+(\d{1,3})\s*$/);
          if (!mQty) continue;
          const body = mQty[1];
          const qty = parseInt(mQty[2], 10) || 0;

          const rawTokens = body.split(/\s+/);
          // vasculha da direita p/ esquerda
          let candidate = '';
          for (let ti = rawTokens.length - 1; ti >= 0; ti--) {
            let tok = rawTokens[ti];
            // junta sinais adjacentes separados (por ex. '+' isolado)
            if ((tok === '+' || tok === '-' || tok === '/') && ti > 0) {
              rawTokens[ti - 1] = rawTokens[ti - 1] + tok;
              continue;
            }
            const clean = tok.replace(/[^A-Za-z0-9+_\-\/\.]/g, '');
            const hasDigit = /\d/.test(clean);
            const hasSpecial = /[+_\-\/\.]/.test(clean);
            if (clean.length >= 2 && (hasDigit || hasSpecial)) {
              candidate = clean;
              break;
            }
          }
          // fallback: √∫ltima palavra relevante antes da quantidade
          if (!candidate) {
            const lastWord = body.split(/\s+/).pop() || '';
            const clean = lastWord.replace(/[^A-Za-z0-9]/g, '');
            if (clean.length >= 3) candidate = clean.toUpperCase();
          }

          if (candidate) {
            console.log('[OCR] Heur√≠stica (linha com quantidade) encontrou', { line, candidate, qty });
            items.push({ sku: candidate, quantidade: qty });
          }
        }
      }

      // ===== Constru√ß√£o do rodap√© (4 linhas) com base no CHECKLIST =====
      // Estrat√©gia: pegar as 4 primeiras linhas originais a partir da linha que come√ßa com "1"
      const rawLines = text.split(/\n/).map(l => l.trim());
      const cleaned = rawLines
        .filter(l => l)
        .filter(l => !/^=+/.test(l))
        .filter(l => !/\b(Produto|SKU|Variac[a√£]o|Quantidade)\b/i.test(l));

      const footerLines = [];
      let footerOneLine = '';
      const idx1 = cleaned.findIndex(l => /^\s*1\b/.test(l));
      if (idx1 >= 0) {
        // Linha da contagem 1: remove o "1" do in√≠cio e mant√©m o restante intacto (inclusive quantidade ao final)
        const firstLine = cleaned[idx1].replace(/^\s*1\s*/, '').trim();
        footerLines.push(firstLine);
        for (let k = idx1 + 1; k < cleaned.length && footerLines.length < 4; k++) {
          // Mant√©m as linhas seguintes exatamente como o OCR retornou
          footerLines.push(cleaned[k]);
        }
      }
      while (footerLines.length < 4) footerLines.push('');

      // ===== Segmenta√ß√£o por COLUNAS (Produto | SKU | Varia√ß√£o | Quantidade) =====
      try {
        const words = Array.isArray(data?.words) ? data.words : [];
        const W = canvas.width, H = canvas.height;
        function norm(s){ return (s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,''); }
        const headerZoneY = H * 0.45; // cabe√ßalho costuma ficar no topo da √°rea
        const headers = { produto: null, sku: null, variacao: null, quantidade: null };
        for (const w of words) {
          const t = norm(w.text || w.symbol || '');
          const y0 = w.bbox?.y0 ?? w.bbox?.y ?? 0;
          if (y0 > headerZoneY) continue;
          if (!headers.produto && t === 'produto') headers.produto = w;
          if (!headers.sku && t === 'sku') headers.sku = w;
          if (!headers.variacao && (t === 'variacao' || t === 'variacao:')) headers.variacao = w;
          if (!headers.quantidade && (t === 'quantidade' || t === 'quantidade:')) headers.quantidade = w;
        }
        // Limites em X das colunas
        const xPos = [];
        if (headers.produto?.bbox?.x0 != null) xPos.push({ key: 'produto', x: headers.produto.bbox.x0 });
        if (headers.sku?.bbox?.x0 != null) xPos.push({ key: 'sku', x: headers.sku.bbox.x0 });
        if (headers.variacao?.bbox?.x0 != null) xPos.push({ key: 'variacao', x: headers.variacao.bbox.x0 });
        if (headers.quantidade?.bbox?.x0 != null) xPos.push({ key: 'quantidade', x: headers.quantidade.bbox.x0 });
        xPos.sort((a,b)=>a.x-b.x);

        let bounds = [];
        if (xPos.length >= 3) {
          for (let i=0;i<xPos.length;i++){
            const left = xPos[i].x - 40; // margem
            const right = (xPos[i+1]?.x ?? (W-10)) - 10;
            bounds.push({ key: xPos[i].key, left: Math.max(0,left), right: Math.min(W,right) });
          }
        } else {
          // fallback: fra√ß√µes fixas
          bounds = [
            { key: 'produto', left: Math.round(W*0.08), right: Math.round(W*0.55) },
            { key: 'sku', left: Math.round(W*0.56), right: Math.round(W*0.66) },
            { key: 'variacao', left: Math.round(W*0.66), right: Math.round(W*0.83) },
            { key: 'quantidade', left: Math.round(W*0.83), right: Math.round(W*0.97) },
          ];
        }

        const headerMaxY = Math.max(
          headers.produto?.bbox?.y1 ?? 0,
          headers.sku?.bbox?.y1 ?? 0,
          headers.variacao?.bbox?.y1 ?? 0,
          headers.quantidade?.bbox?.y1 ?? 0,
          H*0.18
        );
        const rowStartY = headerMaxY + 10;
        const band = H * 0.08; // faixa para capturar a primeira linha ap√≥s o cabe√ßalho

        const colFirst = { produto: '', sku: '', variacao: '', quantidade: '' };
        for (const b of bounds) {
          const colW = words.filter(w => {
            const x0 = w.bbox?.x0 ?? 0, x1 = w.bbox?.x1 ?? 0, y0 = w.bbox?.y0 ?? 0;
            return x0 >= b.left && x1 <= b.right && y0 >= rowStartY;
          });
          if (!colW.length) continue;
          // encontra a menor y (primeira linha)
          const yMin = Math.min(...colW.map(w => w.bbox?.y0 ?? 0));
          const lineWords = colW.filter(w => (w.bbox?.y0 ?? 0) <= yMin + band)
                                .sort((a,b)=>(a.bbox?.x0 ?? 0)-(b.bbox?.x0 ?? 0));
          const txt = lineWords.map(w => (w.text||'').trim()).join(' ').replace(/\s+/g,' ').trim();
          colFirst[b.key] = txt;
        }
        console.log('[OCR] Colunas (primeira linha)', colFirst, bounds);

        // Reconstr√≥i a primeira linha completa e a vers√£o resumida (SKU + Quantidade)
        const firstLine = [colFirst.produto, colFirst.sku, colFirst.variacao, colFirst.quantidade]
          .filter(Boolean)
          .join(' ')
          .replace(/\s+/g,' ')
          .trim();
        if (firstLine) footerLines[0] = firstLine; // substitui linha 1 por linha reconstru√≠da

        const skuLine = (colFirst.sku || '').trim();
        const qtyLine = (colFirst.quantidade || '').trim();
        if (skuLine || qtyLine) {
          footerOneLine = `SKU: ${skuLine} | Quantidade: ${qtyLine}`
            .replace(/\s+\|\s+$/, '')
            .trim();
        }
      } catch (e) {
        console.warn('[OCR] Falha ao segmentar colunas:', e);
      }

      console.log('[OCR] Footer 4 linhas', footerLines);
      console.log('[OCR] Itens extra√≠dos', items);
      if (footerOneLine) console.log('[OCR] Rodap√© (SKU+Qtd)', footerOneLine);
      console.groupEnd();
      return { items, footerLines, footerOneLine };
    }

    async function extractMercadoLivreData(canvas) {
      const { data: { text } } = await Tesseract.recognize(canvas, 'por+eng');
      const lines = text.split(/\n/).map(l => l.trim()).filter(l => l);
      let sku = '', quantidade = 0, loja = '';
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const skuMatch = line.match(/SKU\s*[:\-]?\s*([\w\.\-\/]+)/i);
        if (skuMatch) sku = skuMatch[1];
        const qtdMatch = line.match(/(QTD|QUANTIDADE)\s*[:\-]?\s*(\d+)/i);
        if (qtdMatch) quantidade = parseInt(qtdMatch[2], 10) || 0;
        if (!loja && !line.match(/SKU|QTD|QUANTIDADE/i)) loja = line;
      }
      return { sku, quantidade, loja };
    }

    async function getNextOcrLabelNumber(total) {
      if (!currentUser) return 1;
      const value = Number(total);
      if (!Number.isFinite(value) || value <= 0) return 1;
      const totalSanitizado = Math.max(1, Math.floor(value));
      const ref = db.collection('uid').doc(currentUser.uid).collection('config').doc('contadores');
      try {
        return await db.runTransaction(async tx => {
          const snap = await tx.get(ref);
          const atual = snap.exists ? (snap.data().ocrLastNumber || 0) : 0;
          const inicio = atual + 1;
          const proximo = atual + totalSanitizado;
          tx.set(ref, { ocrLastNumber: proximo }, { merge: true });
          return inicio;
        });
      } catch (err) {
        console.error('Erro ao atualizar o contador de etiquetas OCR:', err);
        return 1;
      }
    }

    async function savePrintedSkuQuantities(items) {
      if (!currentUser || !items || items.length === 0) return;
      const batch = db.batch();
      const userDoc = db.collection('uid').doc(currentUser.uid);
      const respDoc = responsavelExpedicaoUid ? db.collection('uid').doc(responsavelExpedicaoUid) : null;
      items.forEach(item => {
        if (!item || !item.sku) return;
        const quantidadeValida = Number.isFinite(item.quantidade) ? item.quantidade : 0;
        const data = {
          sku: item.sku,
          quantidade: quantidadeValida,
          loja: item.loja || '',
          data: firebase.firestore.FieldValue.serverTimestamp()
        };
        const numeroEtiqueta = item.labelNumber ?? item.numeroEtiqueta;
        if (Number.isFinite(numeroEtiqueta)) data.labelNumber = numeroEtiqueta;
        batch.set(userDoc.collection('etiquetasimpressas').doc(), data);
        if (respDoc) batch.set(respDoc.collection('etiquetasimpressas').doc(), data);
      });
      await batch.commit();
    }

    async function saveLabelSummary(summary) {
      if (!currentUser) return;
      try {
        const totalPaginas = Math.max(0, Math.floor(Number(summary?.totalPaginas) || 0));
        const paginasRaw = Array.isArray(summary?.paginasResumo) ? summary.paginasResumo : [];
        const paginas = paginasRaw.map(p => {
          const numero = Number.isFinite(p?.numero) ? Math.floor(p.numero) : null;
          const sku = (p?.sku || '').toString().trim();
          const quantidade = Number.isFinite(p?.quantidade) ? p.quantidade : null;
          return { numero, sku, quantidade };
        });
        const totaisPorSkuMap = new Map();
        paginas.forEach(p => {
          if (!p.sku) return;
          const quantidade = Number.isFinite(p.quantidade) ? p.quantidade : 0;
          totaisPorSkuMap.set(p.sku, (totaisPorSkuMap.get(p.sku) || 0) + quantidade);
        });
        const totaisPorSku = Array.from(totaisPorSkuMap.entries()).map(([sku, quantidade]) => ({ sku, quantidade }));
        const contadorInicial = Number.isFinite(summary?.contadorInicial) ? Math.floor(summary.contadorInicial) : null;
        const contadorFinal = Number.isFinite(summary?.contadorFinal) ? Math.floor(summary.contadorFinal) : null;
        const baseData = {
          arquivo: summary?.fileName || '',
          totalPaginas: totalPaginas || paginas.length,
          paginas,
          totaisPorSku,
          paginasSemSku: paginas.filter(p => !p.sku).length,
          contadorInicial,
          contadorFinal,
          pdfDocId: summary?.pdfDocId || null,
          pdfUrl: summary?.pdfUrl || '',
          ownerUid: currentUser.uid,
          ownerEmail: currentUser.email || '',
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          foraHorario: Boolean(summary?.foraHorario)
        };
        const userCollection = db.collection('users').doc(currentUser.uid).collection('etiquetasResumo');
        const docRef = userCollection.doc();
        const writes = [docRef.set(baseData)];
        if (responsavelExpedicaoUid) {
          const managerDoc = db.collection('users').doc(responsavelExpedicaoUid).collection('etiquetasResumo').doc(docRef.id);
          writes.push(managerDoc.set(baseData));
        }
        await Promise.all(writes);
      } catch (err) {
        console.error('Erro ao salvar resumo de etiquetas:', err);
      }
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    function updateProgress(current, total, startTime, progressFill, progressText, timerText) {
      const progress = Math.round((current / total) * 100);
      progressFill.style.width = progress + "%";
      if (current > 0) {
        progressText.textContent = `Processando p√°gina ${current} de ${total} (${progress}%)`;
        const elapsed = (Date.now() - startTime) / 1000;
        const avg = elapsed / current;
        const remaining = Math.max(0, Math.round(avg * (total - current)));
        timerText.textContent = `Tempo restante: ${formatTime(remaining)}`;
      } else {
        progressText.textContent = `Preparando (${total} p√°ginas)...`;
        timerText.textContent = "";
      }
    }

    async function uploadPdfToFirebase(blob, fileName, items, extraMeta = {}) {
      if (!currentUser) {
        await savePrintedSkuQuantities(items);
        return;
      }
      try {
        const gestoresRaw = document.getElementById('gestoresEmails').value || '';
        const gestoresEmails = gestoresRaw.split(',').map(e => e.trim()).filter(e => e);
        const selecionado = await escolherGestorEmail(gestoresEmails);
        const totalPaginas = Math.max(0, Math.floor(Number(extraMeta.totalPaginas) || 0));
        const contadorInicial = Number.isFinite(extraMeta.contadorInicial) ? Math.floor(extraMeta.contadorInicial) : null;
        const contadorFinal = Number.isFinite(extraMeta.contadorFinal) ? Math.floor(extraMeta.contadorFinal) : null;
        const foraHorarioAtual = foraDoHorario();
        const docPayload = {
          ownerUid: currentUser.uid,
          ownerEmail: currentUser.email,
          gestoresExpedicaoEmails: selecionado,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          name: fileName,
          foraHorario: foraHorarioAtual,
          totalPaginas
        };
        if (contadorInicial !== null) docPayload.contadorInicial = contadorInicial;
        if (contadorFinal !== null) docPayload.contadorFinal = contadorFinal;
        const docRef = await db.collection('pdfDocs').add(docPayload);
        const fileRef = storage.ref().child(`pdfs/${currentUser.uid}/${docRef.id}.pdf`);
        await fileRef.put(blob);
        const url = await fileRef.getDownloadURL();
        await docRef.update({ url: url, storagePath: fileRef.fullPath });
        const record = {
          name: fileName,
          url: url,
          path: fileRef.fullPath,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          totalPaginas,
          contadorInicial,
          contadorFinal
        };
        await db.collection('users').doc(currentUser.uid).collection('etiquetaenvio').add({ ...record });
        if (
          window.ExpedicaoNotifier &&
          typeof window.ExpedicaoNotifier.notifyNovaEtiqueta === 'function'
        ) {
          await window.ExpedicaoNotifier.notifyNovaEtiqueta({
            db,
            firebase,
            currentUser,
            destinatarioEmails: selecionado,
            destinatarioUids: responsavelExpedicaoUid
              ? [responsavelExpedicaoUid]
              : [],
            arquivoNome: fileName,
            totalPaginas,
            foraHorario: foraHorarioAtual,
            origem: 'Etiquetas PDF (OCR)',
            pdfDocId: docRef.id,
            additionalData: {
              contadorInicial,
              contadorFinal,
            },
          });
        }
        await savePrintedSkuQuantities(items);
        if (Array.isArray(extraMeta.paginasResumo)) {
          await saveLabelSummary({
            totalPaginas,
            paginasResumo: extraMeta.paginasResumo,
            contadorInicial,
            contadorFinal,
            fileName,
            pdfDocId: docRef.id,
            pdfUrl: url,
            foraHorario: foraHorarioAtual
          });
        }
      } catch (err) {
        console.error('Erro ao enviar PDF para Firebase:', err);
        showMessage('Erro ao enviar PDF. Tente novamente mais tarde.');
        throw err;
      }
    }

    async function processar() {
      const status = document.getElementById("status");
      const pdfFile = document.getElementById("pdfInput").files[0];

      if (!pdfFile) {
        return showMessage("Envie o arquivo PDF.");
      }

      openProcessingModal('Processando etiquetas Shopee');
      const startTime = Date.now();
      const allExtractedItems = [];
      const paginasResumo = [];
      let contadorInicial = null;
      let proximoNumeroEtiqueta = 1;
      let contadorInicializado = false;
      let totalPrevisto = 0;
      let uploadIniciado = false;

      try {
        status.textContent = "üì∏ Lendo PDF...";
        const arrayBuffer = await pdfFile.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      const novoPdf = await PDFLib.PDFDocument.create();
      const rodapeFont = await novoPdf.embedFont(PDFLib.StandardFonts.Helvetica);
      const canvas = document.getElementById("pdfCanvas");
      const ctx = canvas.getContext("2d");
      canvas.style.display = "block";
      updateProgress(0, pdf.numPages, startTime, progressFill, progressText, timerText);

      for (let i = 0; i < pdf.numPages; i++) {
        const page = await pdf.getPage(i + 1);
        const scale = 7;
        const viewport = page.getViewport({ scale });

        canvas.width = viewport.width;
        canvas.height = viewport.height;

        await page.render({ canvasContext: ctx, viewport }).promise;
        updateProgress(i + 1, pdf.numPages, startTime, progressFill, progressText, timerText);

        const largura = canvas.width;
        const altura = canvas.height;
        const colWidth = largura / 2;
        const rowHeight = altura / 1.75;

        const pares = [
          { etiqueta: { x: 0, y: 0 }, checklist: { x: 0, y: rowHeight } },
          { etiqueta: { x: colWidth, y: 0 }, checklist: { x: colWidth, y: rowHeight } }
        ];

        if (!contadorInicializado) {
          totalPrevisto = pdf.numPages * pares.length;
          if (currentUser) {
            contadorInicial = await getNextOcrLabelNumber(totalPrevisto);
            proximoNumeroEtiqueta = contadorInicial;
          } else {
            contadorInicial = 1;
            proximoNumeroEtiqueta = 1;
          }
          contadorInicializado = true;
        }

        for (const par of pares) {
          const proporcaoEtiqueta = 0.88;
          const proporcaoChecklist = 0.12;

          const alturaEtiquetaPrincipal = rowHeight * proporcaoEtiqueta;
          const alturaChecklist = rowHeight * proporcaoChecklist;
          const deslocamentoEtiquetaY = 6;

          const etCanvas = document.createElement("canvas");
          etCanvas.width = colWidth;
          etCanvas.height = alturaEtiquetaPrincipal - deslocamentoEtiquetaY;
          const etCtx = etCanvas.getContext("2d");
          etCtx.drawImage(
            canvas,
            par.etiqueta.x,
            par.etiqueta.y + deslocamentoEtiquetaY,
            colWidth,
            alturaEtiquetaPrincipal - deslocamentoEtiquetaY,
            0,
            0,
            colWidth,
            alturaEtiquetaPrincipal - deslocamentoEtiquetaY
          );

          const chkCanvas = document.createElement("canvas");
          const deslocamentoY = 60;
          const novaAlturaChecklist = Math.max(alturaChecklist - deslocamentoY, 100);
          const scaleChecklist = 7;
          chkCanvas.width = Math.floor(colWidth * scaleChecklist);
          chkCanvas.height = Math.floor(novaAlturaChecklist * scaleChecklist);
          const chkCtx = chkCanvas.getContext("2d");
          chkCtx.imageSmoothingEnabled = true;
          chkCtx.imageSmoothingQuality = 'high';
          chkCtx.drawImage(
            canvas,
            par.checklist.x,
            par.checklist.y + deslocamentoY,
            colWidth,
            novaAlturaChecklist,
            0,
            0,
            chkCanvas.width,
            chkCanvas.height
          );

          console.groupCollapsed('[Crop] Par√¢metros de corte');
          console.log({
            pagina: i + 1,
            par,
            colWidth,
            rowHeight,
            proporcaoEtiqueta,
            proporcaoChecklist,
            alturaEtiquetaPrincipal,
            alturaChecklist,
            deslocamentoEtiquetaY,
            deslocamentoY,
            novaAlturaChecklist,
            scaleChecklist
          });
          console.groupEnd();

          const extracted = await extractSkuQuantitiesFromCanvas(chkCanvas, { pagina: i + 1, par });
          const numeroEtiquetaAtual = proximoNumeroEtiqueta;
          proximoNumeroEtiqueta++;

          const etiquetaCompletaCanvas = document.createElement("canvas");
          const paddingX = 0;
          etiquetaCompletaCanvas.width = colWidth + paddingX * 2;
          const ajusteVerticalChecklist = 12;
          etiquetaCompletaCanvas.height =
            (alturaEtiquetaPrincipal - deslocamentoEtiquetaY) +
            ajusteVerticalChecklist;

          const completoCtx = etiquetaCompletaCanvas.getContext("2d");
          completoCtx.imageSmoothingEnabled = true;
          completoCtx.imageSmoothingQuality = 'high';
          completoCtx.drawImage(etCanvas, paddingX, 0);

          const imgBytes = await fetch(etiquetaCompletaCanvas.toDataURL("image/png")).then(res => res.arrayBuffer());
          const imgEmbed = await novoPdf.embedPng(imgBytes);

          const larguraPagina = 293.46;
          const alturaPagina = 475.2;
          const scaleFactor = 0.90;
          const larguraEtiquetaFinal = 277 * scaleFactor;
          const alturaEtiquetaFinal = 449 * scaleFactor;
          const margemX = (larguraPagina - larguraEtiquetaFinal) / 2;
          const margemY = (alturaPagina - alturaEtiquetaFinal) / 2;
          const ajusteVertical = 20;
          const yPos = margemY + ajusteVertical;

          const pag = novoPdf.addPage([larguraPagina, alturaPagina]);
          pag.drawImage(imgEmbed, {
            x: margemX,
            y: yPos,
            width: larguraEtiquetaFinal,
            height: alturaEtiquetaFinal,
          });

          const fallbackItem = extracted?.items && extracted.items[0] ? extracted.items[0] : null;
          const oneLine = extracted?.footerOneLine
            ? extracted.footerOneLine
            : (fallbackItem
                ? `SKU: ${fallbackItem.sku} | Quantidade: ${fallbackItem.quantidade}`
                : (extracted?.footerLines ? extracted.footerLines[0] : ''));

          let saveSku = '';
          let saveQtd = null;
          let possuiQtd = false;
          let skuTxt = '';
          let qtdTxt = '';

          if (oneLine) {
            const mSku = oneLine.match(/SKU\s*:\s*([^|]+?)(?:\s*\||$)/i);
            if (mSku && mSku[1]) {
              saveSku = mSku[1].trim();
              if (saveSku) skuTxt = `SKU: ${saveSku}`;
            }
            const mQtd = oneLine.match(/Quantidade\s*:\s*(\d+)/i);
            if (mQtd && mQtd[1]) {
              const qtdParse = parseInt(mQtd[1], 10);
              if (!Number.isNaN(qtdParse)) {
                saveQtd = qtdParse;
                possuiQtd = true;
                qtdTxt = `Quantidade: ${qtdParse}`;
              }
            }
          }

          if (!saveSku && fallbackItem?.sku != null) {
            const fallbackSku = String(fallbackItem.sku).trim();
            if (fallbackSku) {
              saveSku = fallbackSku;
              skuTxt = `SKU: ${saveSku}`;
            }
          }
          if (!possuiQtd && fallbackItem && fallbackItem.quantidade != null) {
            const qtdFallback = Number(fallbackItem.quantidade);
            if (Number.isFinite(qtdFallback)) {
              saveQtd = qtdFallback;
              possuiQtd = true;
              qtdTxt = `Quantidade: ${qtdFallback}`;
            }
          }

          if (saveSku) {
            allExtractedItems.push({
              sku: saveSku,
              quantidade: possuiQtd ? saveQtd : 0,
              labelNumber: numeroEtiquetaAtual
            });
          }

          paginasResumo.push({
            numero: numeroEtiquetaAtual,
            sku: saveSku || '',
            quantidade: possuiQtd ? saveQtd : null
          });

          const numeroTxt = `Etiqueta N¬∫: ${numeroEtiquetaAtual}`;
          const linhasRodape = [];
          if (skuTxt) linhasRodape.push(skuTxt);
          if (possuiQtd && qtdTxt) linhasRodape.push(qtdTxt);
          linhasRodape.push(numeroTxt);

          const fontSize = 9.5;
          const lineGap = 2;
          const padding = 4;
          const blocoAltura = (fontSize + lineGap) * linhasRodape.length + padding * 2;
          let footerY = yPos - blocoAltura - 2;
          if (footerY < 2) footerY = yPos;

          pag.drawRectangle({
            x: margemX,
            y: footerY,
            width: larguraEtiquetaFinal,
            height: blocoAltura,
            color: PDFLib.rgb(1, 1, 1)
          });

          for (let li = 0; li < linhasRodape.length; li++) {
            pag.drawText(linhasRodape[li], {
              x: margemX + 6,
              y: footerY + padding + li * (fontSize + lineGap),
              size: fontSize,
              font: rodapeFont,
              color: PDFLib.rgb(0, 0, 0)
            });
          }
        }
      }

      progressFill.style.width = "100%";
      const processamentoTotal = Math.round((Date.now() - startTime) / 1000);
      progressText.textContent = "Gerando arquivo final...";
      timerText.textContent = `Processamento em: ${formatTime(processamentoTotal)}. Salvando arquivo...`;

      const pdfFinal = await novoPdf.save();
      const blob = new Blob([pdfFinal], { type: "application/pdf" });
      const fileName = `etiquetas_editadas_${Date.now()}.pdf`;
      const localUrl = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = localUrl;
      a.download = fileName;
      a.click();

      const contadorFinal = contadorInicializado ? (proximoNumeroEtiqueta - 1) : null;
      const totalPaginasGeradas = paginasResumo.length || totalPrevisto;
      status.textContent = "üì§ Enviando ao servidor...";
      uploadIniciado = true;
      await uploadPdfToFirebase(blob, fileName, allExtractedItems, {
        totalPaginas: totalPaginasGeradas,
        paginasResumo,
        contadorInicial: contadorInicializado ? contadorInicial : null,
        contadorFinal
      });
      status.textContent = "‚úÖ PDF gerado com sucesso! Conclu√≠do.";
      progressText.textContent = "‚úÖ Conclu√≠do!";
      timerText.textContent = `Conclu√≠do em: ${formatTime(Math.round((Date.now() - startTime) / 1000))}`;
      markProcessingSuccess('Arquivo final salvo com sucesso!');
      } catch (error) {
        console.error('Erro durante o processamento de etiquetas:', error);
        if (uploadIniciado) {
          status.textContent = "‚ö†Ô∏è PDF gerado, mas houve erro no envio.";
          markProcessingError('N√£o foi poss√≠vel salvar o arquivo no servidor. Verifique e tente novamente.');
        } else {
          status.textContent = '‚ö†Ô∏è Ocorreu um erro ao processar o PDF.';
          markProcessingError('N√£o foi poss√≠vel concluir o processamento. Tente novamente.');
        }
      }
    }

    window.processar = processar;
    async function processarMercadoLivre() {
      const status = document.getElementById("status");
      const pdfFile = document.getElementById("pdfInput").files[0];

      if (!pdfFile) {
        return showMessage("Envie o arquivo PDF.");
      }

      openProcessingModal('Processando etiquetas Mercado Livre');
      const startTime = Date.now();
      const allItems = [];

      try {
        status.textContent = "üì∏ Lendo PDF Mercado Livre...";
        const arrayBuffer = await pdfFile.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const canvas = document.getElementById("pdfCanvas");
        const ctx = canvas.getContext("2d");
        canvas.style.display = "block";
        updateProgress(0, pdf.numPages, startTime, progressFill, progressText, timerText);

        for (let i = 0; i < pdf.numPages; i++) {
          const page = await pdf.getPage(i + 1);
          const scale = 3;
          const viewport = page.getViewport({ scale });
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          await page.render({ canvasContext: ctx, viewport }).promise;
          updateProgress(i + 1, pdf.numPages, startTime, progressFill, progressText, timerText);
          const data = await extractMercadoLivreData(canvas);
          if (data.sku) allItems.push(data);
        }

        progressFill.style.width = "100%";
        const tempoProcessamento = Math.round((Date.now() - startTime) / 1000);
        progressText.textContent = "Gerando resumo de etiquetas...";
        timerText.textContent = `Processamento em: ${formatTime(tempoProcessamento)}. Salvando arquivo...`;

        if (currentUser) {
          status.textContent = "üì§ Enviando ao servidor...";
          const gestoresRaw = document.getElementById('gestoresEmails').value || '';
          const gestoresEmails = gestoresRaw.split(',').map(e => e.trim()).filter(e => e);
          const fileName = `mercado_livre_${Date.now()}.pdf`;
          const selecionado = await escolherGestorEmail(gestoresEmails);
          const docRef = await db.collection('pdfDocs').add({
            ownerUid: currentUser.uid,
            ownerEmail: currentUser.email,
            gestoresExpedicaoEmails: selecionado,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            name: fileName,
            foraHorario: foraDoHorario()
          });
          const fileRef = storage.ref().child(`pdfs/${currentUser.uid}/${docRef.id}.pdf`);
          await fileRef.put(pdfFile);
          const url = await fileRef.getDownloadURL();
          await docRef.update({ url: url, storagePath: fileRef.fullPath });
          const record = {
            name: fileName,
            url: url,
            path: fileRef.fullPath,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
          };
          await db.collection('users').doc(currentUser.uid).collection('etiquetaenvio').add({ ...record });
          if (responsavelExpedicaoUid) {
            const respRecord = {
              name: fileName,
              url: url,
              path: fileRef.fullPath,
              createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            await db.collection('users').doc(responsavelExpedicaoUid).collection('etiquetaenvio').add({ ...respRecord });
          }
          if (
            window.ExpedicaoNotifier &&
            typeof window.ExpedicaoNotifier.notifyNovaEtiqueta === 'function'
          ) {
            await window.ExpedicaoNotifier.notifyNovaEtiqueta({
              db,
              firebase,
              currentUser,
              destinatarioEmails: selecionado,
              destinatarioUids: responsavelExpedicaoUid
                ? [responsavelExpedicaoUid]
                : [],
              arquivoNome: fileName,
              totalEtiquetas: allItems.length,
              foraHorario: foraDoHorario(),
              origem: 'Etiquetas Mercado Livre',
              pdfDocId: docRef.id,
            });
          }
        }

        await savePrintedSkuQuantities(allItems);
        status.textContent = "‚úÖ Etiquetas Mercado Livre processadas! Conclu√≠do.";
        progressText.textContent = "‚úÖ Conclu√≠do!";
        timerText.textContent = `Conclu√≠do em: ${formatTime(Math.round((Date.now() - startTime) / 1000))}`;
        markProcessingSuccess('Arquivo final salvo com sucesso!');
      } catch (error) {
        console.error('Erro durante o processamento de etiquetas Mercado Livre:', error);
        status.textContent = '‚ö†Ô∏è N√£o foi poss√≠vel processar as etiquetas do Mercado Livre.';
        markProcessingError('N√£o foi poss√≠vel concluir o processamento. Tente novamente.');
      }
    }

    window.processarMercadoLivre = processarMercadoLivre;
    </script>

  <script src="shared.js"></script>
  </div>
</body>
</html>
