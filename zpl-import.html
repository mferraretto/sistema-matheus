<!DOCTYPE html> 
<html lang="pt-BR"> 
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Combinador de Etiqueta ZPL</title> 
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css?v=20240826">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- A biblioteca pdf-lib é carregada aqui -->
    <script src="https://unpkg.com/pdf-lib@1.4.0"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
    <script type="module" src="firebase-config.js"></script>
</head> 
<body class="bg-gray-50">
  <div class="app-container">
  <div id="sidebar-container"></div>
  <div id="navbar-container"></div>
  <div class="main-content flex items-center justify-center min-h-screen p-4">

<div class="card-container w-full max-w-2xl flex flex-col gap-6">
    <div class="card bg-white p-8 rounded-xl shadow-lg border border-gray-200"> 
        <h1 class="text-2xl font-semibold text-gray-900 text-center mb-2">Combinador de ZPL</h1> 
        <p class="text-gray-600 text-center mb-6"> 
            Selecione um ficheiro .zpl ou .txt para extrair os dados do checklist e combiná-los na etiqueta de envio. 
        </p> 
        <div class="flex flex-col items-center gap-4">
            <input
                type="file"
                id="zplFile"
                accept=".zpl, .txt"
                class="block w-full max-w-sm text-sm text-gray-500
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-full file:border-0
                        file:text-sm file:font-semibold
                        file:bg-blue-50 file:text-blue-700
                        hover:file:bg-blue-100 cursor-pointer"
            >
            <input
                type="text"
                id="gestoresEmails"
                placeholder="E-mails do gestor de expedição (separados por vírgula)"
                class="block w-full max-w-sm text-sm text-gray-500 border border-gray-300 rounded p-2"
            >
            <button
                id="converterButton"
                class="px-6 py-3 bg-blue-800 text-white font-bold text-lg rounded-full
                        shadow-lg hover:bg-blue-700 transition-all duration-300 transform
                        hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed"
            >
                Extrair e Gerar 
            </button> 
        </div> 

        <!-- Progress bar and status -->
        <div id="progress-container" class="mt-6 hidden">
            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <p id="progress-status" class="text-center text-sm text-gray-600 mt-2"></p>
            <p id="estimated-time" class="text-center text-sm text-gray-600 mt-1"></p>
        </div>
        <div id="success-message" class="text-green-600 font-bold text-center mt-4"></div>
        <div id="error-message" class="text-red-500 font-bold text-center mt-2"></div>
    </div>

</div>
</div>

<div id="gestorModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
  <div class="bg-white w-full max-w-md p-4 rounded shadow-lg">
    <h2 class="text-lg font-semibold mb-2">Enviar arquivo para qual gestor?</h2>
    <select id="gestorSelect" class="form-control mb-4"></select>
    <div class="flex justify-end gap-2">
      <button id="gestorCancel" class="btn btn-secondary">Cancelar</button>
      <button id="gestorConfirm" class="btn btn-primary">Confirmar</button>
    </div>
  </div>
</div>

<script src="expedicao-notifier.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        if (!firebase.apps.length) { firebase.initializeApp(firebaseConfig); }
        const db = firebase.firestore();
        const storage = firebase.storage();
        let currentUser = null;
        let responsavelExpedicaoUid = null;
        let responsavelExpedicaoEmail = null;
        let horariosEtiquetas = [];

        function escolherGestorEmail(emails) {
            return new Promise(resolve => {
                if (!emails || !emails.length) return resolve([]);
                if (emails.length === 1) return resolve([emails[0]]);

                const modal = document.getElementById('gestorModal');
                const select = document.getElementById('gestorSelect');
                const confirmBtn = document.getElementById('gestorConfirm');
                const cancelBtn = document.getElementById('gestorCancel');

                select.innerHTML = '';
                emails.forEach(email => {
                    const opt = document.createElement('option');
                    opt.value = email;
                    opt.textContent = email;
                    select.appendChild(opt);
                });

                function close(value) {
                    modal.classList.add('hidden');
                    confirmBtn.removeEventListener('click', onConfirm);
                    cancelBtn.removeEventListener('click', onCancel);
                    modal.removeEventListener('click', onBackdrop);
                    resolve([value]);
                }

                function onConfirm() { close(select.value || emails[0]); }
                function onCancel() { close(emails[0]); }
                function onBackdrop(e) { if (e.target === modal) close(emails[0]); }

                confirmBtn.addEventListener('click', onConfirm);
                cancelBtn.addEventListener('click', onCancel);
                modal.addEventListener('click', onBackdrop);

                modal.classList.remove('hidden');
            });
        }
        firebase.auth().onAuthStateChanged(async u => {
            currentUser = u;
            if (!u) return;
            try {
                const doc = await db.collection('uid').doc(u.uid).get();
                const data = doc.data() || {};
                const emails = data.gestoresExpedicaoEmails || data.responsavelExpedicaoEmail || '';
                document.getElementById('gestoresEmails').value = Array.isArray(emails) ? emails.join(', ') : emails;
                const respEmail = Array.isArray(data.gestoresExpedicaoEmails)
                    ? data.gestoresExpedicaoEmails[0]
                    : data.responsavelExpedicaoEmail;
                if (respEmail) {
                    responsavelExpedicaoEmail = respEmail;
                    const snap = await db.collection('uid').where('email', '==', respEmail).limit(1).get();
                    if (!snap.empty) responsavelExpedicaoUid = snap.docs[0].id;
                    await carregarHorarios();
                }
            } catch (e) {
                console.error('Erro ao carregar gestor de expedição:', e);
            }
        });
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        async function savePdf(blob, name, meta = {}) {
            if (!currentUser) return;
            const gestoresRaw = document.getElementById('gestoresEmails').value || '';
            const gestoresEmails = gestoresRaw.split(',').map(e => e.trim()).filter(e => e);
            const selecionado = await escolherGestorEmail(gestoresEmails);
            const foraHorarioAtual = foraDoHorario();
            const docRef = await db.collection('pdfDocs').add({
                ownerUid: currentUser.uid,
                ownerEmail: currentUser.email,
                gestoresExpedicaoEmails: selecionado,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                name: name,
                foraHorario: foraHorarioAtual
            });
            const fileRef = storage.ref().child(`pdfs/${currentUser.uid}/${docRef.id}.pdf`);
            await fileRef.put(blob);
            const url = await fileRef.getDownloadURL();
            await docRef.update({ url: url, storagePath: fileRef.fullPath });
            const record = {
                name: name,
                url: url,
                path: fileRef.fullPath,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            await db.collection('users').doc(currentUser.uid).collection('etiquetaenvio').add({ ...record });
            if (responsavelExpedicaoUid) {
                const respRecord = {
                    name: name,
                    url: url,
                    path: fileRef.fullPath,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                await db.collection('users').doc(responsavelExpedicaoUid).collection('etiquetaenvio').add({ ...respRecord });
            }
            if (
              window.ExpedicaoNotifier &&
              typeof window.ExpedicaoNotifier.notifyNovaEtiqueta === 'function'
            ) {
              await window.ExpedicaoNotifier.notifyNovaEtiqueta({
                db,
                firebase,
                currentUser,
                destinatarioEmails: selecionado,
                destinatarioUids: [responsavelExpedicaoUid],
                arquivoNome: name,
                totalEtiquetas: Number.isFinite(meta.totalEtiquetas)
                  ? Number(meta.totalEtiquetas)
                  : undefined,
                totalPaginas: Number.isFinite(meta.totalPaginas)
                  ? Number(meta.totalPaginas)
                  : undefined,
                foraHorario: foraHorarioAtual,
                origem: 'ZPL Import (Gemini)',
                pdfDocId: docRef.id,
              });
            }
        }

        async function savePrintedSkuQuantities(items) {
            if (!currentUser || !items || items.length === 0) return;
            const batch = db.batch();
            const userDoc = db.collection('uid').doc(currentUser.uid);
            const respDoc = responsavelExpedicaoUid ? db.collection('uid').doc(responsavelExpedicaoUid) : null;
            items.forEach(item => {
                const data = {
                    sku: item.sku,
                    quantidade: item.quantidade,
                    loja: item.loja || '',
                    userUid: currentUser.uid,
                    userEmail: currentUser.email,
                    data: firebase.firestore.FieldValue.serverTimestamp()
                };
                batch.set(userDoc.collection('etiquetasimpressas').doc(), data);
                if (respDoc) {
                    batch.set(respDoc.collection('etiquetasimpressas').doc(), data);
                }
            });
            await batch.commit();
        }

        async function carregarHorarios() {
            if (!responsavelExpedicaoUid) return;
            try {
                const doc = await db.collection('uid').doc(responsavelExpedicaoUid).get();
                const data = doc.data() || {};
                horariosEtiquetas = data.horariosEtiquetas || [];
            } catch (e) {
                console.error('Erro ao carregar horários:', e);
            }
        }

        function foraDoHorario() {
            if (!horariosEtiquetas.length) return false;
            const now = new Date();
            return !horariosEtiquetas.some(h => {
                if (!h.inicio || !h.fim) return false;
                const [ih, im] = h.inicio.split(':').map(Number);
                const [fh, fm] = h.fim.split(':').map(Number);
                const start = new Date(now);
                start.setHours(ih, im, 0, 0);
                const end = new Date(now);
                end.setHours(fh, fm, 0, 0);
                return now >= start && now <= end;
            });
        }

        const fileInput = document.getElementById('zplFile');
        const converterButton = document.getElementById('converterButton');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressStatus = document.getElementById('progress-status');
        const estimatedTimeEl = document.getElementById('estimated-time');
        const errorDiv = document.getElementById('error-message');
        const successMessage = document.getElementById('success-message');

        const GEMINI_DELAY_MS = 5000;
        let lastGeminiCall = 0;
        let timerInterval = null;
        let elapsedTime = 0;
        const GEMINI_API_KEYS = [
            "AIzaSyDtQ8xlsTi_BRRoBlr81C9ZLZ4AO_iuzQs",
            "AIzaSyAKFps1dbK5gRjUiL5r1nplFMj6DH4VIWU",
            "AIzaSyDJH-VEkF4ip5dx5sijbvWb6epE4M7JG1s",
            "AIzaSyBv6hDqN-gnTOOJZLDfxHeUXgqxG21sAXI",
            "AIzaSyBMPs0EgLA-bj5ly2uLw03lKJFT6AplarI",
            "AIzaSyAVKvlnqSs6CXbx_uVKFTdEf0AJY3Fj2Os"
        ];
        let geminiKeyIndex = 0;
        function getNextGeminiApiKey() {
            const key = GEMINI_API_KEYS[geminiKeyIndex];
            geminiKeyIndex = (geminiKeyIndex + 1) % GEMINI_API_KEYS.length;
            return key;
        }
        async function fetchWithGeminiDelay(url, options) {
            const now = Date.now();
            const elapsed = now - lastGeminiCall;
            if (elapsed < GEMINI_DELAY_MS) {
                await new Promise(r => setTimeout(r, GEMINI_DELAY_MS - elapsed));
            }
            lastGeminiCall = Date.now();
            return fetch(url, options);
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        // Initial state of the user interface
        converterButton.disabled = true; 

        fileInput.addEventListener('change', () => {
            converterButton.disabled = !fileInput.files.length;
            errorDiv.textContent = '';
            successMessage.textContent = '';
            estimatedTimeEl.textContent = '';
        });

        converterButton.addEventListener('click', processZPL); 

        async function processZPL() {
            const file = fileInput.files && fileInput.files.length > 0 ? fileInput.files.item(0) : null;
            errorDiv.textContent = '';
            successMessage.textContent = '';
            estimatedTimeEl.textContent = '';

            if (!file) {
                errorDiv.textContent = 'Por favor, selecione um ficheiro ZPL para processar.';
                return;
            }

            // Show progress bar and disable button
            progressContainer.classList.remove('hidden');
            progressBar.style.width = '0%';
            progressStatus.textContent = 'A preparar...';
            estimatedTimeEl.textContent = '';
            converterButton.disabled = true;

            try { 
                const zplCode = await readFileAsync(file); 
                // Regex to find ^XA...^XZ blocks, ignoring ^DGR to capture both blocks. 
                const blocks = zplCode.match(/(~DGR[\s\S]*?\^XA[\s\S]*?\^XZ)/g); 

                if (!blocks || blocks.length < 2 || blocks.length % 2 !== 0) { 
                    throw new Error('Não foram encontrados blocos ZPL suficientes para a etiqueta e o checklist, ou o número de blocos é ímpar.'); 
                } 
                
                const dpmm = 8;
                const originalWidthIn = 4.0;
                const originalHeightIn = 5.2;
                const { PDFDocument } = PDFLib;
                const pdfDoc = await PDFDocument.create();
                const totalLabels = blocks.length / 2;
                elapsedTime = 0;
                estimatedTimeEl.textContent = `⏳ Tempo decorrido: ${formatTime(elapsedTime)}`;
                clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    elapsedTime++;
                    estimatedTimeEl.textContent = `⏳ Tempo decorrido: ${formatTime(elapsedTime)}`;
                }, 1000);

                // Recupera o próximo número de etiqueta a partir do Firestore
                let startLabelNumber = 1;
                try {
                    const counterDocRef = db.collection('uid').doc(currentUser.uid);
                    await db.runTransaction(async tx => {
                        const doc = await tx.get(counterDocRef);
                        const current = doc.exists && doc.data().zplLastNumber ? doc.data().zplLastNumber : 0;
                        startLabelNumber = current + 1;
                        tx.set(counterDocRef, { zplLastNumber: current + totalLabels }, { merge: true });
                    });
                } catch (e) {
                    console.error('Erro ao atualizar o contador de etiquetas:', e);
                }

                const allExtractedItems = [];
                let labelCounter = startLabelNumber;

                // Loop to process each pair of ZPL blocks
                for (let i = 0; i < blocks.length; i += 2) {
                    const currentLabelIndex = (i / 2) + 1;
                    progressStatus.textContent = `A processar etiqueta ${currentLabelIndex} de ${totalLabels}...`;
                    progressBar.style.width = `${(currentLabelIndex / totalLabels) * 100}%`;

                    const labelBlock = blocks[i];
                    const checklistBlock = blocks[i + 1];

                    // Extração da loja a partir da etiqueta
                    const loja = await getStoreFromLabel(labelBlock, dpmm, originalWidthIn, originalHeightIn);

                    // 1. Render checklist as an image for analysis
                   const checklistImageBlob = await generateImageFromZpl(checklistBlock, dpmm, originalWidthIn, originalHeightIn);
                    const checklistBase64 = await blobToBase64(checklistImageBlob);

                    // 2. Use Gemini API to extract SKU and quantity
                    const extractedData = await extractDataFromImage(checklistBase64);
                    if (loja) {
                        extractedData.forEach(item => item.loja = loja);
                    }
                    // keep track of all items for posterior saving
                    allExtractedItems.push(...extractedData);

                    // 3. Generate ZPL for the new combined label
                    const combinedZPL = generateCombinedZPL(labelBlock, extractedData, labelCounter);
                    
                    // 4. Calculate new total page height
                    const newTotalHeightInches = calculateNewTotalHeight(originalHeightIn, extractedData.length, dpmm); 
                    
                    // 5. Get PNG of the combined label from Labelary API
                    const combinedPngBlob = await generateImageFromZpl(combinedZPL, dpmm, originalWidthIn, newTotalHeightInches); 
                    const processedPngBlob = await applyBlackContrastFromBlob(combinedPngBlob); 

                    // 6. Create PDF from the processed PNG
                    const pngBytes = await processedPngBlob.arrayBuffer(); 
                    const pngImage = await pdfDoc.embedPng(pngBytes); 
                    const page = pdfDoc.addPage([originalWidthIn * 72, newTotalHeightInches * 72]); 
                    page.drawImage(pngImage, { x: 0, y: 0, width: originalWidthIn * 72, height: newTotalHeightInches * 72 });
                    labelCounter++;
                }

                // 7. Save the final PDF
                const pdfBytes = await pdfDoc.save();
                const pdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });

                const fileName = `etiquetas-combinadas-${Date.now()}.pdf`;

                await savePdf(pdfBlob, fileName, { totalEtiquetas: totalLabels });
                await savePrintedSkuQuantities(allExtractedItems);

                successMessage.textContent = 'Processo concluído e salvo.';

            } catch (error) {
                errorDiv.textContent = `Ocorreu um erro durante o processamento: ${error.message}`;
                console.error('Erro na conversão:', error);
            } finally {
                // Hide progress bar and re-enable button
                clearInterval(timerInterval);
                estimatedTimeEl.textContent = '';
                progressContainer.classList.add('hidden');
                converterButton.disabled = false;
                progressBar.style.width = '0%';
            }
        }
        
        function calculateNewTotalHeight(originalHeightIn, numberOfItems, dpmm) { 
            const fontH = 22; 
            const lineStep = 30; 
            const yPadding = 250; 
            const addedContentHeightDots = numberOfItems * (lineStep + fontH); 
            
            const dotsPerInch = dpmm * 25.4; 
            const addedContentHeightInches = (addedContentHeightDots + yPadding) / dotsPerInch; 
            
            return originalHeightIn + addedContentHeightInches; 
        } 

async function generateImageFromZpl(zplCode, dpmm, width, height) {
            const apiUrl = `https://api.labelary.com/v1/printers/${dpmm}dpmm/labels/${width}x${height}/0/`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Accept': 'image/png',
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: zplCode
            });
            if (!response.ok) { 
                const errorText = await response.text(); 
                throw new Error(`Erro na API Labelary (imagem): ${response.status} ${response.statusText} - ${errorText}`); 
            } 

              return response.blob();
        }

        function extractStoreFromZpl(zplCode) {
            const remRegex = /Remetente\^FS[\s\S]*?\^FD([^\^]+)\^FS/i;
            const match = zplCode.match(remRegex);
            if (match) {
                return match[1].trim();
            }
            const sameLine = /Remetente:?\s*([^\^]+)\^FS/i;
            const matchSame = zplCode.match(sameLine);
            return matchSame ? matchSame[1].trim() : null;
        }

        async function getStoreFromLabel(zplCode, dpmm, width, height) {
            try {
                const lojaFromZpl = extractStoreFromZpl(zplCode);
                if (lojaFromZpl) return lojaFromZpl;
                const labelBlob = await generateImageFromZpl(zplCode, dpmm, width, height);
                const labelBase64 = await blobToBase64(labelBlob);
                return await extractStoreFromImage(labelBase64);
            } catch (e) {
                console.error('Erro ao obter loja da etiqueta:', e);
                return null;
            }
        }

        async function extractStoreFromImage(base64Image) {
            const prompt = `A etiqueta de envio possui o texto \"Remetente\" seguido do nome da loja. Identifique esse nome e retorne apenas um objeto JSON com a chave \"loja\".`;
            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: prompt },
                            {
                                inlineData: {
                                    mimeType: "image/png",
                                    data: base64Image
                                }
                            }
                        ]
                    }
                ],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "loja": { "type": "STRING" }
                        }
                    }
                }
            };
            let result;
            let attempts = 0;
            const maxAttempts = 5;
            let delay = 1000;
            while (attempts < maxAttempts) {
                const apiKey = getNextGeminiApiKey();
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${apiKey}`;
                try {
                    const response = await fetchWithGeminiDelay(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        console.error(`Attempt ${attempts + 1} failed with status: ${response.status} - ${await response.text()}`);
                        if (response.status === 429) {
                            await new Promise(r => setTimeout(r, delay));
                            delay *= 2;
                            attempts++;
                            continue;
                        }
                        throw new Error(`Erro na API Gemini: ${response.status} - ${await response.text()}`);
                    }
                    result = await response.json();
                    break;
                } catch (error) {
                    console.error('API loja call failed, retrying...', error);
                    attempts++;
                    if (attempts === maxAttempts) {
                        throw error;
                    }
                    await new Promise(r => setTimeout(r, delay));
                    delay *= 2;
                }
            }

            if (!result || !result.candidates || result.candidates.length === 0 ||
                !result.candidates.at(0).content || !result.candidates.at(0).content.parts ||
                result.candidates.at(0).content.parts.length === 0) {
                throw new Error("Resposta da API Gemini inválida para loja.");
            }

            const json = result.candidates.at(0).content.parts.at(0).text;
            console.log('Loja extraída da API:', json);
            try {
                return JSON.parse(json).loja || null;
            } catch {
                return null;
            }
        }

        async function extractDataFromImage(base64Image) {
            const prompt = `Dada a imagem de um checklist ZPL, extraia o SKU, a quantidade e a loja. Retorne os resultados num array de objetos JSON, com as chaves "sku", "quantidade" e "loja". Por favor, apenas retorne o JSON e nada mais.`;
            const payload = { 
                contents: [ 
                    { 
                        role: "user", 
                        parts: [ 
                            { text: prompt }, 
                            { 
                                inlineData: { 
                                    mimeType: "image/png", 
                                    data: base64Image 
                                } 
                            } 
                        ] 
                    } 
                ], 
                generationConfig: { 
                    responseMimeType: "application/json", 
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "sku": { "type": "STRING" },
                                "quantidade": { "type": "NUMBER" },
                                "loja": { "type": "STRING" }
                            }
                        }
                    }
                }
            };
            
            let result;
            let attempts = 0;
            const maxAttempts = 5;
            let delay = 1000;

            while (attempts < maxAttempts) {
                const apiKey = getNextGeminiApiKey();
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${apiKey}`;
                try {
                    const response = await fetchWithGeminiDelay(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) { 
                        console.error(`Attempt ${attempts + 1} failed with status: ${response.status} - ${await response.text()}`); 
                        if (response.status === 429) { // Too Many Requests 
                            await new Promise(resolve => setTimeout(resolve, delay)); 
                            delay *= 2; 
                            attempts++; 
                            continue; 
                        } 
                        throw new Error(`Erro na API Gemini: ${response.status} - ${await response.text()}`); 
                    } 
                    
                    result = await response.json(); 
                    break; 
                } catch (error) { 
                    console.error('API call failed, retrying...', error); 
                    attempts++; 
                    if (attempts === maxAttempts) { 
                        throw error; 
                    } 
                    await new Promise(resolve => setTimeout(resolve, delay)); 
                    delay *= 2; 
                } 
            } 

            if (!result || !result.candidates || result.candidates.length === 0 || 
                !result.candidates.at(0).content || !result.candidates.at(0).content.parts || 
                result.candidates.at(0).content.parts.length === 0) { 
                throw new Error("Resposta da API Gemini inválida."); 
            } 
            
            const json = result.candidates.at(0).content.parts.at(0).text; 
            console.log('Dados extraídos da API:', json); 
            return JSON.parse(json); 
        } 

        function generateCombinedZPL(labelBlock, data, labelNumber) {
            let originalContent = labelBlock.replace(/\^XA|\^XZ/g, ''); 
            originalContent = originalContent.replace(/\^A0N,20,20/g, '^ABN,22,22'); 
            const newContentStartX = 50; 
            const newContentStartY = 1200; 
            const fontH = 22; 
            const fontW = 22; 
            const lineStep = 30; 

            let newContentZPL = ''; 
            if (data && data.length > 0) { 
                data.forEach((item, index) => { 
                    const y = newContentStartY + (index * (lineStep + fontH)); 
                    const skuText = `^FO${newContentStartX},${y}^ABN,${fontH},${fontW}^FD SKU: ${item.sku} ^FS`; 
                    const qtdText = `^FO${newContentStartX},${y + fontH + 5}^ABN,${fontH},${fontW}^FD Qtd: ${item.quantidade} ^FS`; 
                    newContentZPL += `${skuText}${qtdText}`; 
                }); 
            } 
            
            const dpmm = 8; 
            const originalHeightIn = 5.2; 
            const totalPageHeightInches = calculateNewTotalHeight(originalHeightIn, data.length, dpmm);
            const totalPageHeightDots = Math.round(totalPageHeightInches * dpmm * 8);
            const numberY = totalPageHeightDots - 420;
            const numberZpl = `^FO50,${numberY}^ABN,22,22^FD${labelNumber}^FS`;

            return `^XA^LL${totalPageHeightDots}^LH0,0${originalContent}${newContentZPL}${numberZpl}^XZ`;
        }

        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    resolve(reader.result);
                };
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        async function applyBlackContrastFromBlob(imageBlob, { contrast = 40, gamma = 0.9, threshold = 200 } = {}) { 
            return new Promise((resolve, reject) => { 
                const imgElement = new Image(); 
                imgElement.onload = () => { 
                    const canvas = document.createElement('canvas'); 
                    canvas.width = imgElement.naturalWidth; 
                    canvas.height = imgElement.naturalHeight; 
                    const ctx = canvas.getContext('2d', { willReadFrequently: true }); 
                    ctx.drawImage(imgElement, 0, 0); 

                    const img = ctx.getImageData(0, 0, canvas.width, canvas.height); 
                    const data = img.data; 

                    const factor = (359 * (contrast + 255)) / (255 * (259 - contrast)); 

                    for (let i = 0; i < data.length; i += 4) { 
                        const r = data[i], g = data[i + 1], b = data[i + 2]; 
                        let y = 0.2126 * r + 0.7152 * g + 0.0722 * b; 

                        if (y < threshold) { 
                            let v = factor * (y - 128) + 128; 
                            v = 255 * Math.pow(v / 255, gamma); 
                            if (v > y) v = y; 
                            if (v < 0) v = 0; 
                            if (v > 255) v = 255; 

                            data[i] = data[i + 1] = data[i + 2] = v; 
                        } else { 
                            const v = y > 255 ? 255 : y; 
                            data[i] = data[i + 1] = data[i + 2] = v; 
                        } 
                    } 
                    ctx.putImageData(img, 0, 0); 
                    canvas.toBlob(resolve, 'image/png', 1); 
                    if (imgElement.src) URL.revokeObjectURL(imgElement.src); 
                }; 
                imgElement.onerror = reject; 
                imgElement.src = URL.createObjectURL(imageBlob); 
            }); 
        } 
    }); 
</script>
<script src="shared.js"></script>

  </div>
</body>
</html>
