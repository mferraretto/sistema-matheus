<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sistema de Sobras - Shopee Premium</title>
  
  <!-- Fontes Google -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
  
  <!-- Bibliotecas CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link rel="stylesheet" href="css/styles.css?v=20240826">
<link rel="stylesheet" href="css/tabs-mobile.css?v=20240826">
  <!-- Bibliotecas JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
      <script type="module" src="firebase-config.js"></script>


</head>
<body class="bg-gray-50">
  <div class="app-container">
    <!-- Sidebar -->
  <div id="sidebar-container"></div>



<!-- Top Navbar -->
  <div id="navbar-container"></div>


    <!-- Conte√∫do Principal -->
    <div class="main-content space-y-10">
      <div class="page-title">
        <i class="fas fa-check-circle"></i>
        <h1>Vendedor Pro - Vendas e Faturamento</h1>
      </div>
      
      
      <div id="firebase-error" class="card" style="display: none;">
        <div class="card-header">
          <i class="fas fa-exclamation-triangle"></i>
          <h3>Erro de Conex√£o com o Firebase</h3>
        </div>
        <p id="error-message" style="margin-bottom: 1rem;"></p>
        <button onclick="verificarConexao()" class="btn btn-primary">
          <i class="fas fa-sync-alt"></i> Tentar Reconectar
        </button>
      </div>
      
      <!-- Tab bar removida -->

      <!-- Aba de Importa√ß√£o/Confer√™ncia -->
      <div id="importar" class="tab-content active">
 
      </div>

      <!-- Aba de Metas -->
      <div id="metas" class="tab-content">
          </div>

      

      <!-- Aba de Gr√°ficos -->
      <div id="graficos" class="tab-content">
     
      </div>

      <!-- Aba de Hist√≥rico -->
      <div id="historico" class="tab-content">
    
      </div>
      
      <!-- Aba de Faturamento -->
      <div id="faturamento" class="tab-content">
       
      </div>

      <!-- Aba de Registro de Faturamento -->
      <div id="registroFaturamento" class="tab-content">
       
      </div>

      <!-- Aba de Controle de Vendas -->
      <div id="controleVendas" class="tab-content">

      </div>

      <!-- Aba de Sobras -->
      <div id="sobras" class="tab-content">

      </div>

      <!-- Aba de Previs√£o -->
      <div id="previsao" class="tab-content">

      </div>

      <!-- Aba de Acompanhamento -->
      <div id="acompanhamento" class="tab-content">

      </div>
      <!-- Aba de Acompanhamento Sobras (Gestor) -->
      <div id="acompanhamentoGestor" class="tab-content">

      </div>
    </div>
  </div>

  <!-- Status de conex√£o -->
  <div id="connectionStatus" class="connection-status offline">
    <div class="status-dot"></div>
    <span>Offline - Trabalhando localmente</span>
  </div>

<script type="module">
    import { firebaseConfig } from './firebase-config.js';
  // =============================================
    // CONFIGURA√á√ÉO INICIAL E VARI√ÅVEIS GLOBAIS
    // =============================================
    // Vari√°veis globais
    let db;
    let metas = {};
    let historico = [];
    let produtos = {};
        let dadosAcompanhamento = [];
    let sobraPorSku = {};
      let resumoSku = {};
      let totalSaquesAcompanhamento = 0;
      let totalComissaoAcompanhamento = 0;
      let usuarioLogado = { uid: null, perfil: '' };
      window.usuarioLogado = usuarioLogado;
let pedidosProcessados = [];
let graficoBarras, graficoPizza, graficoPrevisao;
let previsaoDados = {};
let initialTab = null;
const API_URL = 'https://us-central1-matheus-35023.cloudfunctions.net/proxyDeepSeek';

function normalizeDate(value) {
  if (!value) return '';
  const d = new Date(value);
  if (!isNaN(d)) return d.toISOString().split('T')[0];
  const match = String(value).match(/\d{4}-\d{2}-\d{2}/);
  return match ? match[0] : '';
}
   const tabIds = ['importar','metas','graficos','historico','faturamento','registroFaturamento','controleVendas','sobras','previsao','acompanhamento','acompanhamentoGestor'];
      const tabsLoaded = Promise.all(
        tabIds.map(t =>
          fetch(`sobras-tabs/${t}.html`)
            .then(res => res.text())
            .then(html => {
              const el = document.getElementById(t);
              if (el) el.innerHTML = html;
            })
            .catch(err => {
              console.error('Erro ao carregar aba', t, err);
              updateConnectionStatus(false);
              return '';
            })
        )
      );

      window.addEventListener('online', () => updateConnectionStatus(true));
      window.addEventListener('offline', () => updateConnectionStatus(false));
      updateConnectionStatus(navigator.onLine);

    // =============================================
    // INICIALIZA√á√ÉO DO FIREBASE E CONFIGURA√á√ïES
    // =============================================
    
    // Inicializa√ß√£o mais robusta do Firebase
    document.addEventListener('DOMContentLoaded', async () => {
      initialTab = new URLSearchParams(window.location.search).get('tab') ||
        (window.location.hash ? window.location.hash.substring(1) : null);
      try {
        const app = !firebase.apps.length ? firebase.initializeApp(window.firebaseConfig) : firebase.app();
        db = firebase.firestore(app);
        const auth = firebase.auth();

        auth.onAuthStateChanged(async user => {
          if (!user) {
            window.location.href = 'index.html?login=1';
            return;
          }
          usuarioLogado.uid = user.uid;
          usuarioLogado.email = user.email;
          try {
            const perfilDoc = await db.collection('usuarios').doc(user.uid).get();
            usuarioLogado.perfil = perfilDoc.exists ? (perfilDoc.data().perfil || '') : '';
          } catch (e) {
            console.error('Erro ao obter perfil do usu√°rio:', e);
          }
          await tabsLoaded;
          window.initTooltips && window.initTooltips();

          await carregarProdutos();
          await carregarMetas();
          carregarHistorico();
          await verificarGestorFinanceiro();
          document.getElementById('filtroSKU').addEventListener('input', filtrarPorSKU);
          document.getElementById('filtroHistorico').addEventListener('input', filtrarHistorico);
          document.getElementById('metaSku').addEventListener('input', atualizarPrecoMinimo);
          document.getElementById('filtroStatus').addEventListener('change', filtrarPorSKU);
          document.getElementById('tipoFiltro').addEventListener('change', filtrarPorSKU);
          document.getElementById('btnLimparFiltros')?.addEventListener('click', limparFiltros);
          if (initialTab && document.getElementById(initialTab)) {
            trocarAba(initialTab);
            if (initialTab === 'sobras') {
              carregarSobras();
            }
          }
        });

        // Configura√ß√µes importantes para a conex√£o
        db.settings({
          experimentalForceLongPolling: true
        });

        // Habilita persist√™ncia offline
        firebase.firestore().enablePersistence()
          .catch((err) => {
            if (err.code == 'failed-precondition') {
              console.warn("Persist√™ncia offline n√£o suportada em m√∫ltiplas abas");
            } else if (err.code == 'unimplemented') {
              console.warn("Persist√™ncia offline n√£o dispon√≠vel no navegador");
            }
          });

        // Verifica conex√£o
        verificarConexao();

      } catch (error) {
        console.error("Erro ao inicializar Firebase:", error);
        mostrarErroFirebase(error);
      }
    });

 // Eventos dependentes do carregamento da navbar
    document.addEventListener('navbarLoaded', () => {
      const darkToggle = document.getElementById('darkModeToggle');
      if (darkToggle) {
        darkToggle.addEventListener('click', function() {
          this.classList.toggle('active');
          document.body.classList.toggle('dark-mode');
        });
      }

      const menuToggle = document.querySelector('.menu-toggle');
      if (menuToggle) {
        menuToggle.addEventListener('click', () => {
          document.querySelector('.sidebar')?.classList.toggle('active');
        });
      }
    });

    // =============================================
    // FUN√á√ïES DE GERENCIAMENTO DE CONEX√ÉO
    // =============================================
    async function consultarDeepSeek(mensagemUser) {
      try {
        const resposta = await fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            model: "deepseek-chat",
            messages: [
              { role: "system", content: "Voc√™ √© um analista de sobras de produtos da Shopee." },
              { role: "user", content: mensagemUser }
            ]
          })
        });

        const dados = await resposta.json();
        return dados.choices?.[0]?.message?.content || "‚ùå Sem resposta da IA.";
      } catch (error) {
        console.error("Erro ao consultar DeepSeek:", error);
        updateConnectionStatus(false);
        return "‚ùå Erro ao se comunicar com o servidor.";
      }
    }

    function verificarConexao() {
      firebase.firestore().enableNetwork()
        .then(() => {
          console.log("Conectado ao Firestore");
          document.getElementById('connectionStatus').className = 'connection-status online';
          document.getElementById('connectionStatus').innerHTML = '<div class="status-dot"></div> <span>Online</span>';
        })
        .catch((error) => {
          console.error("Erro de conex√£o:", error);
          document.getElementById('connectionStatus').className = 'connection-status offline';
          document.getElementById('connectionStatus').innerHTML = '<div class="status-dot"></div> <span>Offline - Trabalhando localmente</span>';
        });
    }

    function mostrarErroFirebase(error) {
      const errorBox = document.getElementById('firebase-error');
      const errorMessage = document.getElementById('error-message');
      
      errorMessage.innerHTML = `<strong>${error.message}</strong><br>(C√≥digo: ${error.code})`;
      errorBox.style.display = 'block';

      console.error("Erro Firebase:", error);
      updateConnectionStatus(false);
    }

    function updateConnectionStatus(online) {
      const statusElement = document.getElementById('connectionStatus');
      
      if (online) {
        statusElement.innerHTML = '<div class="status-dot"></div> <span>Online</span>';
        statusElement.className = 'connection-status online';
      } else {
        statusElement.innerHTML = '<div class="status-dot"></div> <span>Offline - Trabalhando localmente</span>';
        statusElement.className = 'connection-status offline';
      }
    }

    // =============================================
    // FUN√á√ïES UTILIT√ÅRIAS
    // =============================================
    
    function mostrarSucesso(mensagem) {
      const alerta = document.getElementById('alertSuccess');
      alerta.querySelector('.alert-content').textContent = mensagem;
      alerta.style.display = 'flex';
      
      setTimeout(() => {
        alerta.style.display = 'none';
      }, 5000);
    }

    function mostrarErro(mensagem) {
      const alerta = document.getElementById('alertError');
      alerta.querySelector('.alert-content').textContent = mensagem;
      alerta.style.display = 'flex';
      
      setTimeout(() => {
        alerta.style.display = 'none';
      }, 5000);
    }

    function toggleLoading(botao, texto) {
      const btnText = botao.querySelector('span') || botao;
      if (botao.classList.contains('loading')) {
        botao.classList.remove('loading');
        btnText.innerHTML = texto;
      } else {
        botao.classList.add('loading');
        btnText.innerHTML = '<div class="loading"></div> Carregando...';
      }
    }

    async function notificarResponsavelFinanceiro(dataRef, loja, bruto, liquido, qtdVendas) {
      try {
        const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
        const dadosUsuario = usuarioDoc.data() || {};
        const autorNome = dadosUsuario.nome || firebase.auth().currentUser?.email || '';
        const autorEmail = firebase.auth().currentUser?.email || '';
        const respEmail = dadosUsuario.responsavelFinanceiroEmail;
        if (!respEmail) return;
        const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
        if (respSnap.empty) return;
        const respDoc = respSnap.docs[0];
        const respData = respDoc.data() || {};
        const responsavelUid = respData.uid || respDoc.id;
        const descricao = `Faturamento de ${dataRef} da loja ${loja} atualizado. Bruto: R$ ${bruto.toFixed(2)}, L√≠quido: R$ ${liquido.toFixed(2)}, Vendas: ${qtdVendas}`;
        await db.collection('financeiroAtualizacoes').add({
          descricao,
          autorUid: usuarioLogado.uid,
          autorNome,
          autorEmail,
          dataFaturamento: dataRef,
          destinatarios: [responsavelUid, usuarioLogado.uid],
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          anexos: [],
          tipo: 'faturamento'
        });
      } catch (e) {
        console.error('Erro ao notificar respons√°vel financeiro:', e);
      }
    }

    async function executarComRetry(operacao, maxTentativas = 3, delay = 1000) {
      let tentativas = 0;
      
      while (tentativas < maxTentativas) {
        try {
          return await operacao();
        } catch (error) {
          tentativas++;
          if (tentativas >= maxTentativas) throw error;
          
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2; // Aumenta o delay exponencialmente
        }
      }
    }
    
    function atualizarPrecoMinimo() {
      const sku = document.getElementById('metaSku').value.trim();
      const custo = produtos[sku]; // usa o campo `custo`
          const info = document.getElementById('custoProdutoInfo');
      const metaInput = document.getElementById('metaValor');

      if (!info || !metaInput) return;

      if (custo) {
        const valorFormatado = parseFloat(custo).toLocaleString('pt-BR', { minimumFractionDigits: 2 });
        info.textContent = `Custo (usado como meta): R$ ${valorFormatado}`;
        info.style.color = '#06d6a0';

        metaInput.value = parseFloat(custo).toFixed(2); // preencher automaticamente o campo de meta
      } else {
        info.textContent = '';
        metaInput.value = '';
      }
    }
    
    // =============================================
    // FUN√á√ïES DE NAVEGA√á√ÉO E INTERFACE
    // =============================================
    
    window.trocarAba = function trocarAba(id) {
        // Remove a classe 'active' de todas as abas
        document.querySelectorAll('.tab-content').forEach(aba => aba.classList.remove('active'));

        // Ativa a aba correspondente, se existir
        const abaSelecionada = document.getElementById(id);
        if (abaSelecionada) {
          abaSelecionada.classList.add('active');
        } else {
          console.warn(`‚ùå Aba com ID '${id}' n√£o encontrada.`);
          return;
        }

        // Atualiza gr√°ficos, se necess√°rio
      if (id === 'graficos') {
        setTimeout(atualizarGraficos, 100);
      }
        };


    // =============================================
    // FUN√á√ïES DE GERENCIAMENTO DE METAS
    // =============================================
    async function carregarProdutos() {
      try {
let consulta;
        if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
          consulta = db.collectionGroup('produtos');
        } else {
          consulta = db.collection('uid').doc(usuarioLogado.uid).collection('produtos');
        }
        const snapshot = await consulta.get();
        produtos = {};
        const datalist = document.getElementById('listaSkus');
        if (datalist) datalist.innerHTML = '';

        snapshot.forEach(doc => {
          const data = doc.data();
          if (!data.sku) return;
          produtos[data.sku] = data.custo;
          if (datalist) {
            const opt = document.createElement('option');
            const preco = data.custo ? parseFloat(data.custo).toLocaleString('pt-BR', { minimumFractionDigits: 2 }) : '0.00';
            opt.value = data.sku;
            opt.label = `${data.sku} - R$ ${preco}`;
            datalist.appendChild(opt);
          }
        });
      } catch (error) {
        console.error('Erro ao carregar produtos:', error);
      }
    }

    async function carregarMetas() {
      try {
        toggleLoading(document.getElementById('btnAdicionarMeta'), '<i class="fas fa-plus"></i> Adicionar Meta');
        
        return await executarComRetry(async () => {
          metas = {};
          // Carrega SKUs e custo dos produtos cadastrados
  let produtosSnapQuery;
          if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
            produtosSnapQuery = db.collectionGroup('produtos');
          } else {
            produtosSnapQuery = db.collection('uid').doc(usuarioLogado.uid).collection('produtos');
          }
          const produtosSnap = await produtosSnapQuery.get();
          produtosSnap.forEach((doc) => {
            const data = doc.data();
            if (data.sku && data.custo !== undefined) {
              metas[data.sku] = {
                valor: parseFloat(data.custo),
                atualizadoEm: new Date()
              };
          produtos[data.sku] = data.custo;
            }
          });

          // Sobrep√µe com metas salvas manualmente se existirem
          let metasSnapQuery = db.collection("metasSKU");
          if (!['adm', 'admin'].includes(usuarioLogado.perfil.toLowerCase())) {
            metasSnapQuery = metasSnapQuery.where('uid', '==', usuarioLogado.uid);
          }
          const metasSnap = await metasSnapQuery.get();
          metasSnap.forEach((doc) => {
            const originalSku = doc.id.replaceAll('__', '/');
            metas[originalSku] = {
              valor: doc.data().valor,
              atualizadoEm: doc.data().atualizadoEm?.toDate() || new Date()
            };
          });
          
          renderizarMetas();
          return true;
        });
      } catch (error) {
        mostrarErroFirebase(`Erro ao carregar metas: ${error.message}`);
        console.error("Erro ao carregar metas:", error);
        return false;
      } finally {
        toggleLoading(document.getElementById('btnAdicionarMeta'), '<i class="fas fa-plus"></i> Adicionar Meta');
      }
    }

    async function carregarHistorico() {
      try {
        return await executarComRetry(async () => {
          historico = [];
          let histQuery = db.collection("historicoMetas");
          if (!['adm', 'admin'].includes(usuarioLogado.perfil.toLowerCase())) {
            histQuery = histQuery.where('uid', '==', usuarioLogado.uid);
          }
          const snapshot = await histQuery.orderBy("data", "desc").limit(50).get();          
          snapshot.forEach((doc) => {
            historico.push({
              sku: doc.data().sku,
              acao: doc.data().acao,
              valorAnterior: doc.data().valorAnterior,
              valorNovo: doc.data().valorNovo,
              data: doc.data().data.toDate(),
              usuario: doc.data().usuario || 'Sistema'
            });
          });
          
          renderizarHistorico();
          return true;
        });
      } catch (error) {
        mostrarErroFirebase(`Erro ao carregar hist√≥rico: ${error.message}`);
        console.error("Erro ao carregar hist√≥rico:", error);
        return false;
      }
    }

    async function registrarHistorico(sku, acao, valorAnterior, valorNovo) {
      try {
        await executarComRetry(async () => {
          await db.collection("historicoMetas").add({
            sku: sku,
            acao: acao,
            valorAnterior: valorAnterior,
            valorNovo: valorNovo,
            data: new Date(),
            usuario: "Usu√°rio", // Em um sistema real, pegaria do auth
            uid: usuarioLogado.uid
          });
          
          // Recarregar hist√≥rico ap√≥s adicionar novo registro
          await carregarHistorico();
          return true;
        });
      } catch (error) {
        console.error("Erro ao registrar hist√≥rico:", error);
        throw error;
      }
    }

    function renderizarMetas() {
      const tbody = document.querySelector('#tabelaMetas tbody');
      tbody.innerHTML = '';
      
      if (Object.keys(metas).length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">Nenhuma meta cadastrada</td></tr>';
        return;
      }
      
      for (let sku in metas) {
        const meta = metas[sku];
        const precoProduto = produtos[sku];
        const dataFormatada = meta.atualizadoEm ? meta.atualizadoEm.toLocaleDateString('pt-BR') : 'N/A';

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${sku}</td>
          <td>${precoProduto ? 'R$ ' + parseFloat(precoProduto).toLocaleString('pt-BR', { minimumFractionDigits: 2 }) : '-'}</td>
          <td>
            <span class="valorMeta">R$ ${meta.valor.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</span>
            <input class="editInput" type="number" value="${meta.valor}" step="0.01" />
          </td>
          <td>${dataFormatada}</td>
          <td>
            <button onclick="editarMeta(this, '${sku}')" class="btn btn-sm" style="background: rgba(99, 102, 241, 0.1); color: var(--primary);">
              <i class="fas fa-edit"></i>
            </button>
            <button onclick="excluirMeta('${sku}', this)" class="btn btn-sm" style="background: rgba(239, 71, 111, 0.1); color: var(--error);">
              <i class="fas fa-trash-alt"></i>
            </button>
          </td>
        `;
        tbody.appendChild(tr);
      }
    }

    function renderizarHistorico() {
      const lista = document.getElementById('listaHistorico');
      lista.innerHTML = '';
      
      if (historico.length === 0) {
        lista.innerHTML = '<div class="history-item" style="text-align: center;">Nenhum registro hist√≥rico encontrado</div>';
        return;
      }
      
      historico.forEach(item => {
        const div = document.createElement('div');
        div.className = 'history-item';
        
        let acaoTexto = '';
        let valorTexto = '';
        
        if (item.acao === 'adicionar') {
          acaoTexto = `<span class="badge badge-success">Adicionado</span>`;
          valorTexto = `Novo valor: R$ ${item.valorNovo?.toFixed(2) || '0.00'}`;
        } else if (item.acao === 'editar') {
          acaoTexto = `<span class="badge badge-warning">Editado</span>`;
          valorTexto = `De R$ ${item.valorAnterior?.toFixed(2) || '0.00'} para R$ ${item.valorNovo?.toFixed(2) || '0.00'}`;
        } else if (item.acao === 'remover') {
          acaoTexto = `<span class="badge badge-danger">Removido</span>`;
          valorTexto = `Valor anterior: R$ ${item.valorAnterior?.toFixed(2) || '0.00'}`;
        }
        
        div.innerHTML = `
          <div class="flex justify-between items-start flex-wrap gap-4 p-4 rounded-lg shadow transition hover:shadow-xl border border-gray-200 bg-white">
            <div>
              <div class="flex items-center gap-2 mb-2">
                <strong class="text-blue-800">${item.sku}</strong>
                ${acaoTexto}
              </div>
              <div class="text-sm text-gray-600">${valorTexto}</div>
              <div class="text-sm text-gray-500 mt-1">üë§ Por: ${item.usuario}</div>
            </div>
            <div class="text-sm text-gray-500 text-right">
              <i class="fas fa-clock"></i>
              ${item.data.toLocaleDateString('pt-BR')}<br>${item.data.toLocaleTimeString('pt-BR')}
            </div>
          </div>
        `;
        
        lista.appendChild(div);
      });
    }

    function filtrarHistorico() {
      const filtro = document.getElementById('filtroHistorico').value.toLowerCase();
      const itens = document.querySelectorAll('#listaHistorico .history-item');
      
      itens.forEach(item => {
        const sku = item.querySelector('strong')?.textContent.toLowerCase() || '';
        item.style.display = sku.includes(filtro) ? '' : 'none';
      });
    }

    async function adicionarMeta() {
      const skuInput = document.getElementById('metaSku');
      const valorInput = document.getElementById('metaValor');
      
      const sku = skuInput.value.trim();
      const valor = parseFloat(valorInput.value);
      
      if (!sku) {
        mostrarErro('Por favor, informe o SKU do produto.');
        skuInput.focus();
        return;
      }
      
      if (isNaN(valor) || valor <= 0) {
        mostrarErro('Por favor, informe um valor v√°lido para a meta (maior que zero).');
        valorInput.focus();
        return;
      }
      if (!produtos[sku]) {
        const usarIA = confirm("SKU n√£o cadastrado. Deseja uma sugest√£o de meta via IA?");
        
        if (usarIA) {
            try {
                const categoria = prompt("Informe a categoria do produto:");
                if (categoria === null) return;
                
                const custo = prompt("Informe o custo do produto:");
                if (custo === null) return;
                
                const margem = prompt("Informe a margem esperada (%):");
                if (margem === null) return;
                
                const concorrentes = prompt("Informe o pre√ßo m√©dio dos concorrentes:");
                if (concorrentes === null) return;

                const promptText = `Sugira uma meta de sobra para: ${categoria} | Custo: R$${custo} | Margem: ${margem}% | Concorrentes: ${concorrentes}`;
                
                const resposta = await consultarDeepSeek(promptText);
                const match = resposta.match(/R\$\s*([\d.,]+)/);
                const valorSugerido = match ? parseFloat(match[1].replace('.', '').replace(',', '.')) : null;
                
                if (valorSugerido && !isNaN(valorSugerido)) {
                    valorInput.value = valorSugerido.toFixed(2);
                    mostrarSucesso(`Sugest√£o da IA: R$ ${valorSugerido.toFixed(2)}`);
                } else {
                    mostrarErro("N√£o consegui extrair o valor. Resposta completa: " + resposta);
                }
            } catch (error) {
                mostrarErro(`Erro na consulta: ${error.message}`);
            }
            return;
        }
        }
      try {
        toggleLoading(document.getElementById('btnAdicionarMeta'), '<i class="fas fa-plus"></i> Adicionar Meta');
        
        const safeSku = sku.replaceAll('/', '__');
        const metaData = {
          valor: valor,
          atualizadoEm: firebase.firestore.FieldValue.serverTimestamp(),
          uid: usuarioLogado.uid
        };
        
        await executarComRetry(async () => {
          await db.collection("metasSKU").doc(safeSku).set(metaData);
          return true;
        });
        
        // Atualizar localmente
        metas[sku] = {
          valor: valor,
          atualizadoEm: new Date()
        };
        
        // Registrar no hist√≥rico
        await registrarHistorico(sku, 'adicionar', null, valor);
        
        renderizarMetas();
        
        skuInput.value = '';
        valorInput.value = '';
        document.getElementById('custoProdutoInfo').textContent = '';
        
        mostrarSucesso(`Meta para o SKU ${sku} adicionada com sucesso!`);
        
        // Atualizar gr√°ficos se estiver na aba
        if (document.getElementById('graficos').classList.contains('active')) {
          atualizarGraficos();
        }
      } catch (error) {
        mostrarErro(`Erro ao adicionar meta: ${error.message}`);
        console.error("Erro ao adicionar meta:", error);
      } finally {
        toggleLoading(document.getElementById('btnAdicionarMeta'), '<i class="fas fa-plus"></i> Adicionar Meta');
      }
    }

    async function editarMeta(botao, sku) {
      const tr = botao.closest('tr');
      const span = tr.querySelector('.valorMeta');
      const input = tr.querySelector('.editInput');
      const icon = botao.querySelector('i');
      
      if (input.style.display === 'none') {
        // Iniciar edi√ß√£o
        input.style.display = 'inline-block';
        span.style.display = 'none';
        icon.className = 'fas fa-save';
        input.focus();
      } else {
        // Salvar edi√ß√£o
        const novoValor = parseFloat(input.value);
        
        if (isNaN(novoValor) || novoValor <= 0) {
          mostrarErro('Por favor, informe um valor v√°lido para a meta (maior que zero).');
          input.focus();
          return;
        }
        
        try {
          icon.className = 'fas fa-spinner fa-spin';
          
          const valorAnterior = metas[sku].valor;
          const safeSku = sku.replaceAll('/', '__');
          const metaData = {
            valor: novoValor,
            atualizadoEm: firebase.firestore.FieldValue.serverTimestamp(),
            uid: usuarioLogado.uid
          };
          
          await executarComRetry(async () => {
            await db.collection("metasSKU").doc(safeSku).set(metaData);
            return true;
          });
          
          // Atualizar localmente
          metas[sku] = {
            valor: novoValor,
            atualizadoEm: new Date()
          };
          
          // Registrar no hist√≥rico
          await registrarHistorico(sku, 'editar', valorAnterior, novoValor);
          
          renderizarMetas();
          mostrarSucesso(`Meta para o SKU ${sku} atualizada com sucesso!`);
          
          // Atualizar gr√°ficos se estiver na aba
          if (document.getElementById('graficos').classList.contains('active')) {
            atualizarGraficos();
          }
        } catch (error) {
          mostrarErro(`Erro ao editar meta: ${error.message}`);
          console.error("Erro ao editar meta:", error);
          // Reverter visualmente
          input.value = metas[sku].valor;
        } finally {
          input.style.display = 'none';
          span.style.display = 'inline-block';
          icon.className = 'fas fa-edit';
        }
      }
    }

    async function excluirMeta(sku, botao) {
      if (!confirm(`Tem certeza que deseja excluir a meta do SKU ${sku}?`)) {
        return;
      }
      
      try {
        const icon = botao.querySelector('i');
        icon.className = 'fas fa-spinner fa-spin';
        
        const valorAnterior = metas[sku].valor;
        const safeSku = sku.replaceAll('/', '__');
        
        await executarComRetry(async () => {
          await db.collection("metasSKU").doc(safeSku).delete();
          return true;
        });
        
        // Remover localmente
        delete metas[sku];
        
        // Registrar no hist√≥rico
        await registrarHistorico(sku, 'remover', valorAnterior, null);
        
        renderizarMetas();
        mostrarSucesso(`Meta para o SKU ${sku} removida com sucesso!`);
        
        // Atualizar gr√°ficos se estiver na aba
        if (document.getElementById('graficos').classList.contains('active')) {
          atualizarGraficos();
        }
      } catch (error) {
        mostrarErro(`Erro ao excluir meta: ${error.message}`);
        console.error("Erro ao excluir meta:", error);
      }
    }

    // =============================================
    // FUN√á√ïES DE PROCESSAMENTO DE PEDIDOS
    // =============================================
    
    function processarPlanilha() {
      const fileInput = document.getElementById('inputExcel');
      const file = fileInput.files[0];
      const feedback = document.getElementById('feedbackImportacao');
      feedback.innerHTML = '';

      if (!file) {
        feedback.innerHTML = '<span class="badge badge-warning">‚ö†Ô∏è Selecione um arquivo</span>';
        return;
      }

      try {
        toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');

        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const data = new Uint8Array(e.target.result);
            const wb = XLSX.read(data, { type: 'array' });
            const sheet = wb.Sheets[wb.SheetNames[0]];
            const pedidos = XLSX.utils.sheet_to_json(sheet);

            processarPedidos(pedidos);
            feedback.innerHTML = '<span class="badge badge-success">‚úîÔ∏è Importado com sucesso</span>';
          } catch (error) {
            feedback.innerHTML = '<span class="badge badge-danger">‚ö†Ô∏è Erro no arquivo</span>';
            console.error("Erro ao ler arquivo:", error);
          } finally {
            toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');
          }
        };

        reader.onerror = function() {
          feedback.innerHTML = '<span class="badge badge-danger">‚ö†Ô∏è Erro no arquivo</span>';
          toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');
        };

        reader.readAsArrayBuffer(file);
      } catch (error) {
        feedback.innerHTML = '<span class="badge badge-danger">‚ö†Ô∏è Erro no arquivo</span>';
        console.error("Erro ao processar arquivo:", error);
        toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');
      }
    }

    function processarPedidos(pedidos) {
      const contagem = {};
      pedidos.forEach(p => {
        const id = p['ID do pedido'];
        if (id) contagem[id] = (contagem[id] || 0) + 1;
      });

      const tbody = document.querySelector('#resultado tbody');
      tbody.innerHTML = '';
      let totalSobra = 0, totalPercentual = 0, totalPedidos = 0;
      
      pedidosProcessados = [];

      pedidos.forEach(p => {
        const id = p['ID do pedido'];
        if (!id || contagem[id] > 1) return;

        const sku = p['N√∫mero de refer√™ncia SKU'] || '';
        const status = (p['Status do pedido'] || '').toLowerCase();
        if (!sku || status.includes('cancelado') || status.includes('n√£o pago')) return;

        const subtotal = parseFloat(p['Subtotal do produto']) || 0;
        const reembolso = parseFloat(p['Reembolso Shopee']) || 0;
        const cupom = parseFloat(p['Cupom do vendedor']) || 0;
        const comissao = parseFloat(p['Taxa de comiss√£o']) || 0;
        const servico = parseFloat(p['Taxa de servi√ßo']) || 0;
        const sobra = subtotal + reembolso - cupom - comissao - servico;
        const meta = metas[sku]?.valor || 0;
        const percentual = meta ? ((sobra - meta) / meta) * 100 : 0;
       const prazo = p['Prazo de coleta'] || p['Prazo de Coleta'] || '';

        const pedidoData = {
          id, sku, subtotal, reembolso, cupom, comissao, servico, sobra, meta, percentual, status, prazo
        };
        
        pedidosProcessados.push(pedidoData);

        const tr = document.createElement('tr');
        
        // Determinar status e √≠cones
        let statusText = '';
        let statusIcon = '';
        let rowClass = '';

        if (meta) {
          if (percentual <= -10) {
            statusText = 'Cr√≠tico';
            statusIcon = '‚ùå';
            rowClass = 'status-critico';
          } else if (percentual <= -5) {
            statusText = 'Aten√ß√£o';
            statusIcon = '‚ö†Ô∏è';
          } else if (percentual >= 5) {
            statusText = 'Bom';
            statusIcon = '‚úîÔ∏è';
            rowClass = 'status-correto';
          } else {
            statusText = 'Normal';
            statusIcon = '‚úîÔ∏è';
          }
        } else {
          statusText = 'Sem meta';
          statusIcon = '‚ö†Ô∏è';
        }

        tr.className = rowClass;
        tr.innerHTML = `
          <td>${id}</td>
          <td>${sku}</td>
          <td>R$ ${subtotal.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${reembolso.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${cupom.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${comissao.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${servico.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td><strong>R$ ${sobra.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</strong><br><small>Meta: R$ ${meta.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</small></td>
          <td>${percentual.toFixed(2)}%</td>
          <td class="status-only" data-status="${statusText}">${statusIcon} ${statusText}</td>
        `;
        
        tbody.appendChild(tr);

        totalSobra += sobra;
        totalPercentual += percentual;
        totalPedidos++;
      });

      // Calcular total esperado com base na quantidade de pedidos por SKU
      const linhas = document.querySelectorAll("#resultado tbody tr");
      let esperadoTotal = 0;
      linhas.forEach(l => {
        const sku = l.children[1].textContent.trim();
        if (metas[sku]) esperadoTotal += metas[sku].valor;
      });
    
      const media = totalPedidos ? (totalPercentual / totalPedidos).toFixed(2) : '0.00';
      const diferencaTotal = totalSobra - esperadoTotal;
      const diferencaPercentual = esperadoTotal ? (diferencaTotal / esperadoTotal) * 100 : 0;

      let diferencaHTML = '';
      if (esperadoTotal > 0) {
        const diferencaClass = diferencaTotal >= 0 ? 'success' : 'danger';
        diferencaHTML = `
          <div style="margin-top: 1rem; padding: 1rem; background: rgba(6, 214, 160, 0.05); border-radius: 12px; border-left: 4px solid var(--${diferencaClass});">
            <h4>
              <span class="badge badge-${diferencaClass}">
                Diferen√ßa Total: R$ ${Math.abs(diferencaTotal).toLocaleString('pt-BR', { minimumFractionDigits: 2 })} 
                (${diferencaPercentual.toFixed(2)}%)
                ${diferencaTotal >= 0 ? 'acima' : 'abaixo'} da meta
              </span>
            </h4>
          </div>
        `;
      }

      document.getElementById('totalSobra').innerHTML = `
        <div class="card">
          <div class="card-header">
            <i class="fas fa-coins"></i>
            <h3>Resumo Financeiro</h3>
          </div>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem;">
            <div style="background: rgba(99, 102, 241, 0.05); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--primary);">
              <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Sobra Total</h4>
              <h2>R$ ${totalSobra.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</h2>
            </div>
            
            <div style="background: rgba(6, 214, 160, 0.05); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--success);">
              <h4 style="color: var(--success); margin-bottom: 0.5rem;">Sobra Esperada</h4>
              <h2>R$ ${esperadoTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</h2>
            </div>
            
            <div style="background: rgba(108, 117, 125, 0.05); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--secondary);">
              <h4 style="color: var(--secondary); margin-bottom: 0.5rem;">M√©dia de Desempenho</h4>
              <h2>${media}%</h2>
            </div>
          </div>
          ${diferencaHTML}
        </div>
      `;
        document.getElementById('totalSobra').innerHTML += `
        <div style="margin-top: 1.5rem;">
           
        </div>
    `;
    
    // Salvar dados para an√°lise posterior
    window.dadosParaAnalise = {
        pedidos: pedidosProcessados,
        resumo: {
            totalSobra,
            esperadoTotal,
            media
        }
    };
      const sobras = pedidosProcessados.map(p => {
  return {
    sku: p.sku,
    vendido: p.subtotal,
    sobra: p.sobra,
    meta: p.meta,
    data: new Date().toLocaleDateString()
  };
});

document.getElementById("dadosSobrasIA").value = sobras.map(s => {
  return `SKU: ${s.sku}, Vendido: R$ ${s.vendido.toFixed(2)}, Sobra: R$ ${s.sobra.toFixed(2)}, Meta: R$ ${s.meta?.toFixed(2) || 0}, Data: ${s.data}`;
}).join("\n");
        renderizarTabelaLogistica();
}

      // Atualizar gr√°ficos se estiver na aba
      if (document.getElementById('graficos').classList.contains('active')) {
        atualizarGraficos();
      }
    

    function limparFiltros() {
      document.getElementById("filtroSKU").value = "";
      document.getElementById("filtroStatus").value = "";
      document.getElementById("tipoFiltro").value = "exata";
      filtrarPorSKU();
    }
// =============================================
    // CONTROLE LOG√çSTICO DE PEDIDOS
    // =============================================

    function salvarLogistica() {
      localStorage.setItem('controleLogistica', JSON.stringify(logistica));
    }

    function renderizarTabelaLogistica() {
      const tbody = document.querySelector('#tabelaLogistica tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      const hoje = new Date();

      pedidosProcessados.forEach(p => {
        if (!logistica[p.id]) {
          logistica[p.id] = {
            status: 'pendente',
            rastreio: '',
            checklist: { itens: false, etiqueta: false, lacre: false },
            prazo: p.prazo || '',
            dataPostagem: null
          };
        }
        const item = logistica[p.id];
        const prazoData = item.prazo ? new Date(item.prazo) : null;
        const prazoProximo = prazoData && (prazoData - hoje) / (1000 * 60 * 60 * 24) <= 1 && item.status !== 'postado';
        const statusLinha = prazoProximo ? 'prazo' : item.status;
        const postadoPrazo = item.status === 'postado' && item.dataPostagem && prazoData ? new Date(item.dataPostagem) <= prazoData : null;

        const tr = document.createElement('tr');
        tr.dataset.status = statusLinha;

        const progresso = (item.status === 'postado' ? 1 : 0) + (item.checklist.itens ? 1 : 0) + (item.checklist.etiqueta ? 1 : 0) + (item.checklist.lacre ? 1 : 0);
        const progressoPercent = (progresso / 4) * 100;
        const corProgresso = progressoPercent === 100 ? 'var(--success)' : (progressoPercent >= 50 ? '#f59e0b' : 'var(--error)');

        tr.innerHTML = `
          <td>${p.id}</td>
          <td class="${statusLinha !== 'postado' ? 'text-red-600 font-bold' : ''}">
            <select onchange="atualizarStatusLogistica('${p.id}', this.value)" class="form-control">
              <option value="pendente"${item.status === 'pendente' ? ' selected' : ''}>Pendente</option>
              <option value="postado"${item.status === 'postado' ? ' selected' : ''}>Postado</option>
            </select>
          </td>
          <td><input type="text" class="form-control" value="${item.rastreio}" onchange="atualizarRastreio('${p.id}', this.value)" placeholder="C√≥digo" /></td>
          <td>
            <label><input type="checkbox" onchange="atualizarChecklist('${p.id}','itens', this.checked)" ${item.checklist.itens ? 'checked' : ''}/> Itens</label><br>
            <label><input type="checkbox" onchange="atualizarChecklist('${p.id}','etiqueta', this.checked)" ${item.checklist.etiqueta ? 'checked' : ''}/> Etiqueta</label><br>
            <label><input type="checkbox" onchange="atualizarChecklist('${p.id}','lacre', this.checked)" ${item.checklist.lacre ? 'checked' : ''}/> Lacre</label>
          </td>
          <td><div class="progress"><div class="progress-bar" style="width:${progressoPercent}%; background:${corProgresso};"></div></div></td>
          <td>${postadoPrazo === null ? '-' : postadoPrazo ? 'Sim' : 'N√£o'}</td>
        `;
        tbody.appendChild(tr);
      });

      salvarLogistica();
      verificarAlertasLogistica();
      aplicarFiltroLogistica();
    }

    function atualizarStatusLogistica(id, status) {
      if (!logistica[id]) return;
      logistica[id].status = status;
      if (status === 'postado') {
        logistica[id].dataPostagem = new Date().toISOString().split('T')[0];
      }
      salvarLogistica();
      renderizarTabelaLogistica();
    }

    function atualizarRastreio(id, codigo) {
      if (!logistica[id]) return;
      logistica[id].rastreio = codigo;
      salvarLogistica();
    }

    function atualizarChecklist(id, campo, valor) {
      if (!logistica[id]) return;
      logistica[id].checklist[campo] = valor;
      salvarLogistica();
    }

    function aplicarFiltroLogistica() {
      const filtro = document.getElementById('filtroStatusLogistica')?.value;
      document.querySelectorAll('#tabelaLogistica tbody tr').forEach(tr => {
        tr.style.display = !filtro || tr.dataset.status === filtro ? '' : 'none';
      });
    }

    function verificarAlertasLogistica() {
      const valores = Object.values(logistica);
      const pendentes = valores.filter(v => v.status !== 'postado').length;
      const prazoProximo = valores.filter(v => {
        if (!v.prazo || v.status === 'postado') return false;
        const diff = (new Date(v.prazo) - new Date()) / (1000 * 60 * 60 * 24);
        return diff <= 1;
      }).length;

      const mensagens = [];
      if (pendentes) mensagens.push(`${pendentes} pedidos pendentes de envio`);
      if (prazoProximo) mensagens.push(`${prazoProximo} com prazo de coleta pr√≥ximo`);
      const alertaEl = document.getElementById('alertasLogistica');
      if (alertaEl) alertaEl.textContent = mensagens.join(' | ');
    }
    // =============================================
    // FUN√á√ïES DE GR√ÅFICOS
    // =============================================
    
    function atualizarGraficos() {
        // Elemento do cabe√ßalho
        const chartHeader = document.querySelector('.chart-header');
        
        // Limpa o conte√∫do anterior
        chartHeader.innerHTML = '<div class="chart-title">Compara√ß√£o entre Sobra Real e Meta por SKU</div>';
        
        // Verifica√ß√£o de dados
        if (pedidosProcessados.length === 0) {
            document.querySelectorAll('.chart-container').forEach(container => {
                container.innerHTML = '<p style="text-align: center; color: var(--gray); padding: 2rem;">Nenhum dado dispon√≠vel para exibir gr√°ficos. Processe um arquivo primeiro.</p>';
            });
            
            // Adiciona bot√£o mesmo sem dados (opcional)
            chartHeader.innerHTML += `
                <button onclick="analisarTendenciasIA()" class="btn btn-outline" disabled>
                    <i class="fas fa-chart-line"></i> Analisar Tend√™ncias com IA
                </button>
            `;
            return;
        }
        
        // Adiciona bot√£o funcional quando h√° dados
        chartHeader.innerHTML += `
            <button onclick="analisarTendenciasIA()" class="btn btn-outline">
                <i class="fas fa-chart-line"></i> Analisar Tend√™ncias com IA
            </button>
        `;
        
        // Processamento dos dados
        const tipoFiltro = document.getElementById('filtroGrafico').value;
        let dados = agruparPorSKU(pedidosProcessados);
        
        // Aplicar filtro
        if (tipoFiltro === 'top10') {
            dados.sort((a, b) => b.diferencaPercentual - a.diferencaPercentual);
            dados = dados.slice(0, 10);
        } else if (tipoFiltro === 'bottom10') {
            dados.sort((a, b) => a.diferencaPercentual - b.diferencaPercentual);
            dados = dados.slice(0, 10);
        }
        
        // Criar gr√°ficos
        criarGraficoBarras(dados);
        criarGraficoPizza(dados);
    }

    function agruparPorSKU(pedidos) {
      const agrupados = {};
      
      pedidos.forEach(pedido => {
        if (!agrupados[pedido.sku]) {
          agrupados[pedido.sku] = {
            sku: pedido.sku,
            totalSobra: 0,
            totalMeta: 0,
            quantidade: 0
          };
        }
        
        agrupados[pedido.sku].totalSobra += pedido.sobra;
        agrupados[pedido.sku].totalMeta += pedido.meta || 0;
        agrupados[pedido.sku].quantidade += 1;
      });
      
      // Converter para array e calcular diferen√ßas
      return Object.values(agrupados).map(item => {
        const diferenca = item.totalSobra - item.totalMeta;
        const diferencaPercentual = item.totalMeta ? (diferenca / item.totalMeta) * 100 : 0;
        
        return {
          ...item,
          diferenca,
          diferencaPercentual
        };
      });
    } // ‚Üê Fechamento correto da fun√ß√£o
    async function analisarTendenciasIA() {
        try {
            const prompt = `Analise estes dados de desempenho de produtos:
    ${JSON.stringify(pedidosProcessados.slice(0, 50), null, 2)}

    Identifique:
    1. Tend√™ncias sazonais
    2. Produtos com crescimento/decl√≠nio consistente
    3. Sugest√µes de ajuste de estoque
    4. Previs√£o para pr√≥xima semana

    Responda em t√≥picos curtos e diretos.`;

            const resposta = await consultarDeepSeek(prompt);
            
            // Exibir resultado
            document.querySelector('.chart-header').innerHTML += `
                <div class="card" style="margin-top: 1.5rem;">
                    <div class="card-header">
                        <i class="fas fa-lightbulb"></i>
                        <h3>An√°lise de Tend√™ncias</h3>
                    </div>
                    <div style="padding: 1.5rem;">
                        <pre style="white-space: pre-wrap;">${resposta}</pre>
                    </div>
                </div>
            `;
        } catch (error) {
            mostrarErro(`Erro na an√°lise de tend√™ncias: ${error.message}`);
        }
    }
    function criarGraficoBarras(dados) {
      const ctx = document.getElementById('graficoBarras').getContext('2d');
      
      // Destruir gr√°fico anterior se existir
      if (graficoBarras) {
        graficoBarras.destroy();
      }
      
      // Preparar dados
      const labels = dados.map(item => item.sku);
      const sobras = dados.map(item => item.totalSobra);
      const metas = dados.map(item => item.totalMeta);
      
      graficoBarras = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Sobra Real (R$)',
              data: sobras,
              backgroundColor: 'rgba(249, 115, 22, 0.7)',
              borderColor: 'rgba(249, 115, 22, 1)',
              borderWidth: 1
            },
            {
              label: 'Meta Esperada (R$)',
              data: metas,
              backgroundColor: 'rgba(34, 197, 94, 0.7)',
              borderColor: 'rgba(34, 197, 94, 1)',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Valor (R$)'
              }
            },
            x: {
              title: {
                display: true,
                text: 'SKU'
              }
            }
          },
          plugins: {
            title: {
              display: true,
              text: 'Compara√ß√£o entre Sobra Real e Meta por SKU'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  let label = context.dataset.label || '';
                  if (label) {
                    label += ': ';
                  }
                  label += 'R$ ' + context.raw.toLocaleString('pt-BR', { minimumFractionDigits: 2 });
                  return label;
                }
              }
            }
          }
        }
      });
    }

    function criarGraficoPizza(dados) {
      const ctx = document.getElementById('graficoPizza').getContext('2d');
      
      // Destruir gr√°fico anterior se existir
      if (graficoPizza) {
        graficoPizza.destroy();
      }
      
      // Preparar dados - vamos mostrar a diferen√ßa percentual
      const labels = dados.map(item => item.sku);
      const diferencas = dados.map(item => item.diferencaPercentual);
      
      // Criar cores baseadas no desempenho
      const backgroundColors = diferencas.map(val => {
        if (val >= 5) return 'rgba(76, 175, 80, 0.7)'; // Verde - acima
        if (val <= -5) return 'rgba(244, 67, 54, 0.7)'; // Vermelho - abaixo
        return 'rgba(255, 193, 7, 0.7)'; // Amarelo - dentro do esperado
      });
      
      graficoPizza = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: diferencas,
            backgroundColor: backgroundColors,
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Desempenho vs Meta por SKU (%)'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const label = context.label || '';
                  const value = context.raw || 0;
                  return `${label}: ${value.toFixed(2)}%`;
                }
              }
            }
          }
        }
      });
    }
    window.importarFaturamento = async function () {
      const input = document.getElementById("inputFaturamento");
      const file = input.files[0];
      if (!file) return mostrarErro("Selecione um arquivo para importar.");

      const { value: form, isConfirmed } = await Swal.fire({
        title: 'Informa√ß√µes de Faturamento',
        html: `\n          <input type="date" id="swal-data" class="swal2-input" />\n          <input type="text" id="swal-loja" class="swal2-input" placeholder="Nome da Loja" />\n        `,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: 'Continuar',
        preConfirm: () => {
          const data = document.getElementById('swal-data').value;
          const lojaNome = document.getElementById('swal-loja').value.trim();
          if (!data || !/^\d{4}-\d{2}-\d{2}$/.test(data) || lojaNome.length < 2) {
            Swal.showValidationMessage('Informe uma data e uma loja v√°lidas.');
          }
          return { data, loja: lojaNome };
        }
      });
      if (!isConfirmed || !form) return;
      const dataReferencia = form.data;
      const loja = form.loja;

      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: "array" });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet);
          const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
          const dadosUsuario = usuarioDoc.data() || {};
          const respEmail = dadosUsuario.responsavelFinanceiroEmail || null;
          let baseResp = null;
          if (respEmail) {
            const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
            if (!respSnap.empty) {
              const respDoc = respSnap.docs[0];
              const respData = respDoc.data() || {};
              const responsavelUid = respData.uid || respDoc.id;
              baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const gestorEmail = Array.isArray(dadosUsuario.gestoresExpedicaoEmails)
            ? dadosUsuario.gestoresExpedicaoEmails[0]
            : dadosUsuario.responsavelExpedicaoEmail || null;
          let baseExp = null;
          if (gestorEmail) {
            const expSnap = await db.collection('usuarios').where('email', '==', gestorEmail).limit(1).get();
            if (!expSnap.empty) {
              const expDoc = expSnap.docs[0];
              const expData = expDoc.data() || {};
              const gestorUid = expData.uid || expDoc.id;
              baseExp = db.collection('uid').doc(gestorUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const ref = db
            .collection('uid')
            .doc(usuarioLogado.uid)
            .collection('faturamento')
            .doc(dataReferencia)
            .collection('lojas')
            .doc(loja);
          const doc = await ref.get();

          let operacao = "salvar";
          if (doc.exists) {
            const { isConfirmed: substituir, isDenied: somar } = await Swal.fire({
              title: 'Registro existente',
              text: 'J√° existe um registro para esta loja e data. O que deseja fazer?',
              showDenyButton: true,
              showCancelButton: true,
              confirmButtonText: 'Substituir',
              denyButtonText: 'Somar',
              cancelButtonText: 'Cancelar'
            });
            if (!substituir && !somar) return;
            operacao = somar ? "somar" : "substituir";
          }

            let bruto = 0, taxas = 0, qtdVendas = 0;
            const skusVendidos = {};
            const pedidosErrados = [];

            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('faturamentoProgressBar');
            const progressText = document.getElementById('faturamentoProgressText');
            if (progressContainer && progressBar && progressText) {
              progressContainer.classList.remove('hidden');
              progressBar.style.width = '0%';
              progressText.textContent = '0%';
            }
            const totalRows = rows.length;
            let processedRows = 0;
            const updateProgress = async () => {
              if (progressBar && progressText) {
                const pct = Math.round((processedRows / totalRows) * 100);
                progressBar.style.width = pct + '%';
                progressText.textContent = pct + '%';
                if (processedRows % 50 === 0) await new Promise(r => setTimeout(r, 0));
              }
            };

            for (const row of rows) {
            const status = (row['Status do pedido'] || '').toLowerCase();
            if (status.includes('cancelado') || status.includes('n√£o pago')) {
              processedRows++;
              await updateProgress();
              continue;
            }

            const subtotal = parseFloat(row['Subtotal do produto']) || 0;
            const reembolso = parseFloat(row['Reembolso Shopee']) || 0;
            const cupom = parseFloat(row['Cupom do vendedor']) || 0;
            const comissao = parseFloat(row['Taxa de comiss√£o']) || 0;
            const servico = parseFloat(row['Taxa de servi√ßo']) || 0;

            const liquidoLinha = subtotal + reembolso - cupom - comissao - servico;

            bruto += subtotal + reembolso;
            taxas += cupom + comissao + servico;
            qtdVendas++;

              const headers = Object.keys(row);
              const headerSKU = headers.find(h => h.trim() === 'N√∫mero de refer√™ncia SKU'); // pega o nome exato
              const sku = headerSKU ? row[headerSKU] : null;
              if (!sku) {
                processedRows++;
                await updateProgress();
                continue;
              }

              if (!skusVendidos[sku]) skusVendidos[sku] = { total: 0, valorLiquido: 0 };
              skusVendidos[sku].total++;
              skusVendidos[sku].valorLiquido += liquidoLinha;

              const headerPedido = headers.find(h => h.toLowerCase().includes('pedido') && h.toLowerCase().includes('id'));
              const pedidoId = headerPedido ? row[headerPedido] : null;
              const headerQtd = headers.find(h => h.toLowerCase().includes('quantidade'));
              const quantidade = headerQtd ? parseInt(row[headerQtd]) || 0 : 0;
              const metaUnit = metas[sku]?.valor || 0;
              const metaEsperada = metaUnit * (quantidade || 1);
              const sobraReal = liquidoLinha;

              if (metaEsperada && sobraReal < metaEsperada * 0.9) {
                pedidosErrados.push({
                  dia: dataReferencia,
                  loja: loja,
                  pedido: pedidoId,
                  sku: sku,
                  quantidade: quantidade,
                  subtotal: subtotal,
                  sobraReal: sobraReal,
                  totalLiquido: sobraReal,
                  sobraEsperada: metaEsperada,
                  uid: usuarioLogado.uid,
                  critico: true
                });
              }

              processedRows++;
              await updateProgress();
            }
            if (progressBar && progressText) {
              progressBar.style.width = '100%';
              progressText.textContent = '100%';
            }
            if (pedidosErrados.length) {
              const errRef = db
                .collection('uid')
                .doc(usuarioLogado.uid)
                .collection('pedidosErrados');
              await Promise.all(pedidosErrados.map(p => errRef.add(p)));
            }

            const liquido = bruto - taxas;

          if (operacao === "somar" && doc.exists) {
            const anterior = doc.data();
            bruto += anterior.valorBruto || 0;
            taxas += anterior.taxasPlataforma || 0;
            qtdVendas += anterior.qtdVendas || 0;
          }

          // Salvar SKUs vendidos
 const refSku = db
            .collection('uid')
            .doc(usuarioLogado.uid)
            .collection('skusVendidos')
            .doc(dataReferencia);
          await refSku.set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true }); // garante doc pai e marca usu√°rio
          if (baseResp) {
            await baseResp
              .collection('skusVendidos')
              .doc(dataReferencia)
              .set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
          }

          const { encryptString, decryptString } = await import('./crypto.js');
          for (const [sku, dadosSku] of Object.entries(skusVendidos)) {
            const skuId = String(sku).replace(/[.#$\/\[\]]/g, "_");
 const docRef = db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('skusVendidos')
              .doc(dataReferencia)
              .collection('lista')
              .doc(skuId);
            const docSnap = await docRef.get();

            let totalFinal = dadosSku.total;
            let valorLiquidoFinal = dadosSku.valorLiquido;
            if (docSnap.exists) {
              const dadosAnteriores = docSnap.data();
              totalFinal += dadosAnteriores.total || 0;
              valorLiquidoFinal += dadosAnteriores.valorLiquido || 0;
            }

            await docRef.set({
              sku: sku,
              total: totalFinal,
              valorLiquido: valorLiquidoFinal,
              data: dataReferencia,
              loja: loja,
              uid: usuarioLogado.uid
            });
            if (baseResp && respEmail) {
              const skuPayload = {
                sku: sku,
                total: totalFinal,
                valorLiquido: valorLiquidoFinal,
                data: dataReferencia,
                loja: loja,
                uid: usuarioLogado.uid
              };
              const encSku = await encryptString(JSON.stringify(skuPayload), respEmail);
              await baseResp
                .collection('skusVendidos')
                .doc(dataReferencia)
                .collection('lista')
                .doc(skuId)
                .set({ encrypted: encSku, uid: usuarioLogado.uid });
            }
          }
          
          const pass = getPassphrase() || usuarioLogado.uid;

          const pedidosRef = db.collection('uid').doc(usuarioLogado.uid).collection('pedidosreais');
          for (const row of rows) {
            const statusPedido = row['Status do pedido'] || '';
            const headersPedido = Object.keys(row);
            const headerSku = headersPedido.find(h => h.trim() === 'N√∫mero de refer√™ncia SKU');
            const skuPedido = headerSku ? row[headerSku] : null;
           const headerPedidoId = headersPedido.find(h => h.toLowerCase().includes('pedido') && h.toLowerCase().includes('id'));
           const pedidoId = headerPedidoId ? row[headerPedidoId] : null;
           const headerPagamento = headersPedido.find(h => h.toLowerCase().includes('hora do pagamento'));
           const horaPagamento = headerPagamento ? row[headerPagamento] : null;
           const headerPrevEnvio = headersPedido.find(h => h.toLowerCase().includes('data prevista') && h.toLowerCase().includes('envio'));
           let dataPrevistaEnvio = headerPrevEnvio ? row[headerPrevEnvio] : null;
           dataPrevistaEnvio = normalizeDate(dataPrevistaEnvio);
           const headerRastreamento = headersPedido.find(h => h.toLowerCase().includes('rastreamento'));
           const numeroRastreamento = headerRastreamento ? String(row[headerRastreamento]).trim() : '';
            const subtotalPedido = parseFloat(row['Subtotal do produto']) || 0;
            const reembolsoPedido = parseFloat(row['Reembolso Shopee']) || 0;
            const cupomPedido = parseFloat(row['Cupom do vendedor']) || 0;
            const comissaoPedido = parseFloat(row['Taxa de comiss√£o']) || 0;
            const servicoPedido = parseFloat(row['Taxa de servi√ßo']) || 0;
            const taxasPedido = cupomPedido + comissaoPedido + servicoPedido;
            const liquidoPedido = subtotalPedido + reembolsoPedido - taxasPedido;
            if (!pedidoId) continue;
            const pedidoPayload = {
              pedidoId,
              status: statusPedido,
              sku: skuPedido,
              loja,
              data: dataReferencia,
              horaPagamento,
              subtotal: subtotalPedido,
              taxas: taxasPedido,
              liquido: liquidoPedido,
              reembolso: reembolsoPedido
            };
            if (dataPrevistaEnvio) pedidoPayload.dataPrevistaEnvio = dataPrevistaEnvio;
            if (numeroRastreamento) {
              pedidoPayload.numeroRastreamento = numeroRastreamento;
              pedidoPayload.etiquetaImpressa = true;
            }

            const pedidoDocRef = pedidosRef
              .doc(dataReferencia)
              .collection('lista')
              .doc(pedidoId);
            const pedidoDoc = await pedidoDocRef.get();
            let needsUpdate = true;
            if (pedidoDoc.exists) {
              try {
                const atual = JSON.parse(
                  await decryptString(pedidoDoc.data().encrypted, pass)
                );
                if (JSON.stringify(atual) === JSON.stringify(pedidoPayload)) {
                  needsUpdate = false;
                }
              } catch (e) {
                console.error('Erro ao comparar pedido existente', e);
              }
            }
            if (needsUpdate) {
              const encPedido = await encryptString(JSON.stringify(pedidoPayload), pass);
              await pedidoDocRef.set({ encrypted: encPedido, uid: usuarioLogado.uid });
              if (baseResp && respEmail) {
                const encPedidoResp = await encryptString(JSON.stringify(pedidoPayload), respEmail);
                await baseResp
                  .collection('pedidosreais')
                  .doc(dataReferencia)
                  .collection('lista')
                  .doc(pedidoId)
                  .set({ encrypted: encPedidoResp, uid: usuarioLogado.uid });
              }
              if (baseExp && gestorEmail) {
                const encPedidoExp = await encryptString(JSON.stringify(pedidoPayload), gestorEmail);
                await baseExp
                  .collection('pedidosreais')
                  .doc(dataReferencia)
                  .collection('lista')
                  .doc(pedidoId)
                  .set({ encrypted: encPedidoExp, uid: usuarioLogado.uid });
              }
            }
          }

          const lojaPayload = {
            valorBruto: bruto,
            taxasPlataforma: taxas,
            valorLiquido: liquido,
            qtdVendas: qtdVendas,
            loja: loja,
            atualizadoEm: new Date(),
            uid: usuarioLogado.uid
         };
          const encLoja = await encryptString(JSON.stringify(lojaPayload), pass);
          await ref.set({ encrypted: encLoja, uid: usuarioLogado.uid });
          if (baseResp && respEmail) {
            const encLojaResp = await encryptString(JSON.stringify(lojaPayload), respEmail);
            await baseResp
              .collection('faturamento')
              .doc(dataReferencia)
              .collection('lojas')
              .doc(loja)
              .set({ encrypted: encLojaResp, uid: usuarioLogado.uid });
          }

          const resumoPayload = {
            valorBruto: bruto,
            valorLiquido: liquido,
            taxasPlataforma: taxas,
            vendas: qtdVendas,
            atualizadoEm: new Date(),
            uid: usuarioLogado.uid
        };
          const encResumo = await encryptString(JSON.stringify(resumoPayload), pass);
await db
            .collection('uid')
            .doc(usuarioLogado.uid)
            .collection('faturamento')
            .doc(dataReferencia)
            .set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
          if (baseResp && respEmail) {
            const encResumoResp = await encryptString(JSON.stringify(resumoPayload), respEmail);
            await baseResp
              .collection('faturamento')
              .doc(dataReferencia)
              .set({ encrypted: encResumoResp, uid: usuarioLogado.uid }, { merge: true });
          }
          document.getElementById("resultadoFaturamento").innerHTML = `
            <div class="alert alert-success">
              <i class="fas fa-check-circle"></i>
              Faturamento de <strong>${dataReferencia}</strong> da loja <strong>${loja}</strong> registrado com sucesso.<br>
              <strong>Bruto:</strong> R$ ${bruto.toFixed(2)}<br>
              <strong>Taxas:</strong> R$ ${taxas.toFixed(2)}<br>
              <strong>L√≠quido:</strong> R$ ${liquido.toFixed(2)}<br>
              <strong>Qtd. Vendas:</strong> ${qtdVendas}
            </div>
          `;
          await notificarResponsavelFinanceiro(dataReferencia, loja, bruto, liquido, qtdVendas);

        } catch (err) {
          mostrarErro("Erro ao importar: " + err.message);
          console.error(err);
        }
      };

      reader.readAsArrayBuffer(file);
    };

    window.importarFaturamentoMassa = async function () {
      const input = document.getElementById("inputFaturamentoMassa");
      const file = input?.files?.[0];
      if (!file) return mostrarErro("Selecione um arquivo para importar.");

      const { value: form, isConfirmed } = await Swal.fire({
        title: 'Importa√ß√£o em Massa',
        html: `<input type="text" id="swal-loja-massa" class="swal2-input" placeholder="Nome da Loja" />`,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: 'Continuar',
        preConfirm: () => {
          const lojaNome = document.getElementById('swal-loja-massa').value.trim();
          if (lojaNome.length < 2) {
            Swal.showValidationMessage('Informe uma loja v√°lida.');
          }
          return { loja: lojaNome };
        }
      });
      if (!isConfirmed || !form) return;
      const loja = form.loja;

      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: "array" });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet);
          if (!rows.length) {
            mostrarErro("A planilha est√° vazia.");
            return;
          }

          const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
          const dadosUsuario = usuarioDoc.data() || {};
          const respEmail = dadosUsuario.responsavelFinanceiroEmail || null;
          let baseResp = null;
          if (respEmail) {
            const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
            if (!respSnap.empty) {
              const respDoc = respSnap.docs[0];
              const respData = respDoc.data() || {};
              const responsavelUid = respData.uid || respDoc.id;
              baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const gestorEmail = Array.isArray(dadosUsuario.gestoresExpedicaoEmails)
            ? dadosUsuario.gestoresExpedicaoEmails[0]
            : dadosUsuario.responsavelExpedicaoEmail || null;
          let baseExp = null;
          if (gestorEmail) {
            const expSnap = await db.collection('usuarios').where('email', '==', gestorEmail).limit(1).get();
            if (!expSnap.empty) {
              const expDoc = expSnap.docs[0];
              const expData = expDoc.data() || {};
              const gestorUid = expData.uid || expDoc.id;
              baseExp = db.collection('uid').doc(gestorUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const progressContainer = document.getElementById('progressContainer');
          const progressBar = document.getElementById('faturamentoProgressBar');
          const progressText = document.getElementById('faturamentoProgressText');
          if (progressContainer && progressBar && progressText) {
            progressContainer.classList.remove('hidden');
            progressBar.style.width = '0%';
            progressText.textContent = '0%';
          }

          const totalRows = rows.length;
          let processedRows = 0;
          const updateProgress = async () => {
            if (progressBar && progressText) {
              const pct = Math.round((processedRows / totalRows) * 100);
              progressBar.style.width = pct + '%';
              progressText.textContent = pct + '%';
              if (processedRows % 50 === 0) await new Promise(r => setTimeout(r, 0));
            }
          };

          const grupos = {};
          const rowsSemData = [];
          const extrairDataPagamento = (valor) => {
            if (valor === undefined || valor === null) return null;
            const texto = String(valor).trim();
            if (!texto) return null;
            const match = texto.match(/(\d{4}-\d{2}-\d{2})/);
            return match ? match[1] : null;
          };

          for (const row of rows) {
            const headers = Object.keys(row);
            const dataPagamento = extrairDataPagamento(
              headers
                .filter(h => h.toLowerCase().includes('hora do pagamento'))
                .map(h => row[h])[0]
            ) || extrairDataPagamento(
              headers
                .filter(h => h.toLowerCase().includes('data do pedido'))
                .map(h => row[h])[0]
            ) || extrairDataPagamento(
              headers
                .filter(h => h.toLowerCase().includes('data de cria√ß√£o'))
                .map(h => row[h])[0]
            );

            if (!dataPagamento) {
              rowsSemData.push(row);
              processedRows++;
              await updateProgress();
              continue;
            }

            if (!grupos[dataPagamento]) {
              grupos[dataPagamento] = {
                rows: [],
                bruto: 0,
                taxas: 0,
                qtdVendas: 0,
                skusVendidos: {},
                pedidosErrados: []
              };
            }

            const grupo = grupos[dataPagamento];
            grupo.rows.push({ row, headers });

            const status = (row['Status do pedido'] || '').toLowerCase();
            const ativo = !(status.includes('cancelado') || status.includes('n√£o pago'));
            if (ativo) {
              const subtotal = parseFloat(row['Subtotal do produto']) || 0;
              const reembolso = parseFloat(row['Reembolso Shopee']) || 0;
              const cupom = parseFloat(row['Cupom do vendedor']) || 0;
              const comissao = parseFloat(row['Taxa de comiss√£o']) || 0;
              const servico = parseFloat(row['Taxa de servi√ßo']) || 0;
              const liquidoLinha = subtotal + reembolso - cupom - comissao - servico;

              grupo.bruto += subtotal + reembolso;
              grupo.taxas += cupom + comissao + servico;
              grupo.qtdVendas++;

              const headerSku = headers.find(h => h.trim() === 'N√∫mero de refer√™ncia SKU')
                || headers.find(h => h.trim() === 'N¬∫ de refer√™ncia do SKU principal');
              const sku = headerSku ? row[headerSku] : null;

              if (sku) {
                if (!grupo.skusVendidos[sku]) grupo.skusVendidos[sku] = { total: 0, valorLiquido: 0 };
                grupo.skusVendidos[sku].total++;
                grupo.skusVendidos[sku].valorLiquido += liquidoLinha;

                const headerPedido = headers.find(h => h.toLowerCase().includes('pedido') && h.toLowerCase().includes('id'));
                const pedidoId = headerPedido ? row[headerPedido] : null;
                const headerQtd = headers.find(h => h.toLowerCase().includes('quantidade'));
                const quantidade = headerQtd ? parseInt(row[headerQtd]) || 0 : 0;
                const metaUnit = metas[sku]?.valor || 0;
                const metaEsperada = metaUnit * (quantidade || 1);
                const sobraReal = liquidoLinha;

                if (metaEsperada && sobraReal < metaEsperada * 0.9) {
                  grupo.pedidosErrados.push({
                    dia: dataPagamento,
                    loja: loja,
                    pedido: pedidoId,
                    sku: sku,
                    quantidade: quantidade,
                    subtotal: subtotal,
                    sobraReal: sobraReal,
                    totalLiquido: sobraReal,
                    sobraEsperada: metaEsperada,
                    uid: usuarioLogado.uid,
                    critico: true
                  });
                }
              }
            }

            processedRows++;
            await updateProgress();
          }

          if (!Object.keys(grupos).length) {
            mostrarErro('Nenhum registro com data de pagamento foi encontrado.');
            return;
          }

          const { encryptString, decryptString } = await import('./crypto.js');
          const pass = getPassphrase() || usuarioLogado.uid;
          const pedidosRef = db.collection('uid').doc(usuarioLogado.uid).collection('pedidosreais');
          const resultados = [];

          for (const [dataReferencia, grupo] of Object.entries(grupos)) {
            const ref = db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('faturamento')
              .doc(dataReferencia)
              .collection('lojas')
              .doc(loja);
            const doc = await ref.get();
            let operacao = 'salvar';
            let dadosAnteriores = null;

            if (doc.exists) {
              const { isConfirmed: substituir, isDenied: somar } = await Swal.fire({
                title: 'Registro existente',
                text: `J√° existe um registro para ${loja} em ${dataReferencia}. O que deseja fazer?`,
                showDenyButton: true,
                showCancelButton: true,
                confirmButtonText: 'Substituir',
                denyButtonText: 'Somar',
                cancelButtonText: 'Pular'
              });
              if (!substituir && !somar) {
                resultados.push({ data: dataReferencia, loja, status: 'ignorado' });
                continue;
              }
              operacao = somar ? 'somar' : 'substituir';
              const docData = doc.data();
              if (docData?.encrypted) {
                try {
                  dadosAnteriores = JSON.parse(await decryptString(docData.encrypted, pass));
                } catch (e) {
                  console.error('Erro ao descriptografar faturamento existente', e);
                }
              } else {
                dadosAnteriores = docData;
              }
            }

            if (operacao === 'somar' && dadosAnteriores) {
              grupo.bruto += dadosAnteriores.valorBruto || 0;
              grupo.taxas += dadosAnteriores.taxasPlataforma || 0;
              grupo.qtdVendas += dadosAnteriores.qtdVendas || 0;
            }

            if (grupo.pedidosErrados.length) {
              const errRef = db
                .collection('uid')
                .doc(usuarioLogado.uid)
                .collection('pedidosErrados');
              await Promise.all(grupo.pedidosErrados.map(p => errRef.add(p)));
            }

            const liquido = grupo.bruto - grupo.taxas;

            const refSku = db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('skusVendidos')
              .doc(dataReferencia);
            await refSku.set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
            if (baseResp) {
              await baseResp
                .collection('skusVendidos')
                .doc(dataReferencia)
                .set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
            }

            for (const [sku, dadosSku] of Object.entries(grupo.skusVendidos)) {
              const skuId = String(sku).replace(/[.#$\\/\\[\\]]/g, '_');
              const docRef = db
                .collection('uid')
                .doc(usuarioLogado.uid)
                .collection('skusVendidos')
                .doc(dataReferencia)
                .collection('lista')
                .doc(skuId);
              const docSnap = await docRef.get();

              let totalFinal = dadosSku.total;
              let valorLiquidoFinal = dadosSku.valorLiquido;
              if (docSnap.exists) {
                const dadosAnterioresSku = docSnap.data();
                totalFinal += dadosAnterioresSku.total || 0;
                valorLiquidoFinal += dadosAnterioresSku.valorLiquido || 0;
              }

              await docRef.set({
                sku: sku,
                total: totalFinal,
                valorLiquido: valorLiquidoFinal,
                data: dataReferencia,
                loja: loja,
                uid: usuarioLogado.uid
              });
              if (baseResp && respEmail) {
                const skuPayload = {
                  sku: sku,
                  total: totalFinal,
                  valorLiquido: valorLiquidoFinal,
                  data: dataReferencia,
                  loja: loja,
                  uid: usuarioLogado.uid
                };
                const encSku = await encryptString(JSON.stringify(skuPayload), respEmail);
                await baseResp
                  .collection('skusVendidos')
                  .doc(dataReferencia)
                  .collection('lista')
                  .doc(skuId)
                  .set({ encrypted: encSku, uid: usuarioLogado.uid });
              }
            }

            for (const { row, headers } of grupo.rows) {
              const headersLower = headers.map(h => h.toLowerCase());
              const headerPedidoId = headersLower.find((h) => h.includes('pedido') && h.includes('id'));
              const pedidoHeaderOriginal = headerPedidoId ? headers[headersLower.indexOf(headerPedidoId)] : null;
              const pedidoId = pedidoHeaderOriginal ? row[pedidoHeaderOriginal] : null;
              if (!pedidoId) continue;

              const headerPagamento = headersLower.find(h => h.includes('hora do pagamento'));
              const pagamentoOriginal = headerPagamento ? headers[headersLower.indexOf(headerPagamento)] : null;
              const horaPagamento = pagamentoOriginal ? row[pagamentoOriginal] : null;

              const headerCancelar = headersLower.find(h => h.includes('cancelar motivo'));
              const cancelarOriginal = headerCancelar ? headers[headersLower.indexOf(headerCancelar)] : null;
              const cancelarMotivoBruto = cancelarOriginal ? row[cancelarOriginal] : null;
              const cancelarMotivo = cancelarMotivoBruto ? String(cancelarMotivoBruto).trim() : '';

              const headerSkuPrimarioIdx = headersLower.findIndex(h =>
                h.includes('n√∫mero de refer√™ncia sku') || h.includes('numero de referencia sku')
              );
              const headerSkuPrincipalIdx = headersLower.findIndex(h =>
                h.includes('n¬∫ de refer√™ncia do sku principal') ||
                h.includes('n¬∞ de refer√™ncia do sku principal') ||
                h.includes('no de refer√™ncia do sku principal') ||
                h.includes('n o de refer√™ncia do sku principal')
              );
              const headerSkuPrimario = headerSkuPrimarioIdx >= 0 ? headers[headerSkuPrimarioIdx] : null;
              const headerSkuPrincipal = headerSkuPrincipalIdx >= 0 ? headers[headerSkuPrincipalIdx] : null;
              let numeroReferenciaSku = headerSkuPrimario ? row[headerSkuPrimario] : null;
              numeroReferenciaSku = numeroReferenciaSku !== null && numeroReferenciaSku !== undefined
                ? String(numeroReferenciaSku).trim()
                : '';
              const skuPrincipalValorBruto = headerSkuPrincipal ? row[headerSkuPrincipal] : null;
              const skuPrincipalValor = skuPrincipalValorBruto !== null && skuPrincipalValorBruto !== undefined
                ? String(skuPrincipalValorBruto).trim()
                : '';
              if (!numeroReferenciaSku && skuPrincipalValor) {
                numeroReferenciaSku = skuPrincipalValor;
              }

              const headerQtd = headersLower.find(h => h.includes('quantidade'));
              const qtdOriginal = headerQtd ? headers[headersLower.indexOf(headerQtd)] : null;
              const quantidade = qtdOriginal ? parseFloat(row[qtdOriginal]) || 0 : 0;

              const subtotalPedido = parseFloat(row['Subtotal do produto']) || 0;
              const reembolsoPedido = parseFloat(row['Reembolso Shopee']) || 0;
              const cupomPedido = parseFloat(row['Cupom do vendedor']) || 0;
              const comissaoPedido = parseFloat(row['Taxa de comiss√£o']) || 0;
              const servicoPedido = parseFloat(row['Taxa de servi√ßo']) || 0;
              const taxasPedido = cupomPedido + comissaoPedido + servicoPedido;
              const liquidoPedido = subtotalPedido + reembolsoPedido - taxasPedido;

              const headerPrevEnvio = headersLower.find(h => h.includes('data prevista') && h.includes('envio'));
              const prevEnvioOriginal = headerPrevEnvio ? headers[headersLower.indexOf(headerPrevEnvio)] : null;
              let dataPrevistaEnvio = prevEnvioOriginal ? row[prevEnvioOriginal] : null;
              dataPrevistaEnvio = normalizeDate(dataPrevistaEnvio);

              const headerRastreamento = headersLower.find(h => h.includes('rastreamento'));
              const rastreamentoOriginal = headerRastreamento ? headers[headersLower.indexOf(headerRastreamento)] : null;
              const numeroRastreamento = rastreamentoOriginal ? String(row[rastreamentoOriginal]).trim() : '';

              const statusPedido = row['Status do pedido'] || '';

              const pedidoPayload = {
                pedidoId,
                status: statusPedido,
                loja,
                data: dataReferencia,
                horaPagamento,
                quantidade,
                subtotal: subtotalPedido,
                cupom: cupomPedido,
                reembolso: reembolsoPedido,
                comissao: comissaoPedido,
                servico: servicoPedido,
                taxas: taxasPedido,
                liquido: liquidoPedido
              };
              if (numeroReferenciaSku) pedidoPayload.sku = numeroReferenciaSku;
              if (cancelarMotivo) pedidoPayload.cancelarMotivo = cancelarMotivo;

              const dadosPlanilhaPedido = {
                'Status do pedido': statusPedido,
                'Cancelar Motivo': cancelarMotivo || null,
                'N√∫mero de refer√™ncia SKU': numeroReferenciaSku || null,
                Quantidade: quantidade,
                'Subtotal do produto': subtotalPedido,
                'Cupom do vendedor': cupomPedido,
                'Reembolso Shopee': reembolsoPedido,
                'Taxa de comiss√£o': comissaoPedido,
                'Taxa de servi√ßo': servicoPedido
              };
              if (headerSkuPrincipal) {
                dadosPlanilhaPedido['N¬∫ de refer√™ncia do SKU principal'] = skuPrincipalValor || null;
              }
              pedidoPayload.dadosPlanilha = dadosPlanilhaPedido;
              if (dataPrevistaEnvio) pedidoPayload.dataPrevistaEnvio = dataPrevistaEnvio;
              if (numeroRastreamento) {
                pedidoPayload.numeroRastreamento = numeroRastreamento;
                pedidoPayload.etiquetaImpressa = true;
              }

              const pedidoDocRef = pedidosRef
                .doc(dataReferencia)
                .collection('lista')
                .doc(pedidoId);
              const pedidoDoc = await pedidoDocRef.get();
              let needsUpdate = true;
              if (pedidoDoc.exists) {
                try {
                  const atual = JSON.parse(
                    await decryptString(pedidoDoc.data().encrypted, pass)
                  );
                  if (JSON.stringify(atual) === JSON.stringify(pedidoPayload)) {
                    needsUpdate = false;
                  }
                } catch (e) {
                  console.error('Erro ao comparar pedido existente', e);
                }
              }

              if (needsUpdate) {
                const encPedido = await encryptString(JSON.stringify(pedidoPayload), pass);
                await pedidoDocRef.set({ encrypted: encPedido, uid: usuarioLogado.uid });
                if (baseResp && respEmail) {
                  const encPedidoResp = await encryptString(JSON.stringify(pedidoPayload), respEmail);
                  await baseResp
                    .collection('pedidosreais')
                    .doc(dataReferencia)
                    .collection('lista')
                    .doc(pedidoId)
                    .set({ encrypted: encPedidoResp, uid: usuarioLogado.uid });
                }
                if (baseExp && gestorEmail) {
                  const encPedidoExp = await encryptString(JSON.stringify(pedidoPayload), gestorEmail);
                  await baseExp
                    .collection('pedidosreais')
                    .doc(dataReferencia)
                    .collection('lista')
                    .doc(pedidoId)
                    .set({ encrypted: encPedidoExp, uid: usuarioLogado.uid });
                }
              }
            }

            const lojaPayload = {
              valorBruto: grupo.bruto,
              taxasPlataforma: grupo.taxas,
              valorLiquido: liquido,
              qtdVendas: grupo.qtdVendas,
              loja: loja,
              atualizadoEm: new Date(),
              uid: usuarioLogado.uid
            };
            const encLoja = await encryptString(JSON.stringify(lojaPayload), pass);
            await ref.set({ encrypted: encLoja, uid: usuarioLogado.uid });
            if (baseResp && respEmail) {
              const encLojaResp = await encryptString(JSON.stringify(lojaPayload), respEmail);
              await baseResp
                .collection('faturamento')
                .doc(dataReferencia)
                .collection('lojas')
                .doc(loja)
                .set({ encrypted: encLojaResp, uid: usuarioLogado.uid });
            }

            const resumoPayload = {
              valorBruto: grupo.bruto,
              valorLiquido: liquido,
              taxasPlataforma: grupo.taxas,
              vendas: grupo.qtdVendas,
              atualizadoEm: new Date(),
              uid: usuarioLogado.uid
            };
            const encResumo = await encryptString(JSON.stringify(resumoPayload), pass);
            await db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('faturamento')
              .doc(dataReferencia)
              .set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
            if (baseResp && respEmail) {
              const encResumoResp = await encryptString(JSON.stringify(resumoPayload), respEmail);
              await baseResp
                .collection('faturamento')
                .doc(dataReferencia)
                .set({ encrypted: encResumoResp, uid: usuarioLogado.uid }, { merge: true });
            }

            resultados.push({
              data: dataReferencia,
              loja,
              status: 'ok',
              bruto: grupo.bruto,
              taxas: grupo.taxas,
              liquido,
              qtd: grupo.qtdVendas
            });
            await notificarResponsavelFinanceiro(dataReferencia, loja, grupo.bruto, liquido, grupo.qtdVendas);
          }

          if (progressBar && progressText) {
            progressBar.style.width = '100%';
            progressText.textContent = '100%';
          }

          const sucesso = resultados.filter(r => r.status === 'ok');
          const ignorados = resultados.filter(r => r.status === 'ignorado');

          let html = '';
          if (sucesso.length) {
            html += '<div class="alert alert-success">';
            html += '<i class="fas fa-check-circle"></i> Faturamentos processados:';
            html += '<ul class="mt-2 space-y-1">';
            html += sucesso
              .map(r => `<li><strong>${r.data}</strong> - ${r.loja}: Bruto R$ ${r.bruto.toFixed(2)}, Taxas R$ ${r.taxas.toFixed(2)}, L√≠quido R$ ${r.liquido.toFixed(2)}, Vendas ${r.qtd}</li>`)
              .join('');
            html += '</ul></div>';
          }
          if (ignorados.length || rowsSemData.length) {
            html += '<div class="alert alert-warning mt-4">';
            html += '<i class="fas fa-exclamation-triangle"></i> Aten√ß√£o:';
            if (ignorados.length) {
              html += `<br>${ignorados.length} dia(s) foram ignorados por op√ß√£o do usu√°rio.`;
            }
            if (rowsSemData.length) {
              html += `<br>${rowsSemData.length} registro(s) sem data de pagamento foram desconsiderados.`;
            }
            html += '</div>';
          }

          document.getElementById('resultadoFaturamento').innerHTML = html || '<div class="alert alert-info"><i class="fas fa-info-circle"></i> Nenhum faturamento foi processado.</div>';
          input.value = '';
        } catch (err) {
          mostrarErro('Erro ao importar: ' + err.message);
          console.error(err);
        }
      };

      reader.readAsArrayBuffer(file);
    };

    // =============================================
    // FUN√á√ïES DE EXPORTA√á√ÉO
    // =============================================

    function toggleExportMenu() {
      const menu = document.getElementById('exportMenu');
      if (menu) {
        menu.classList.toggle('show');
      }
    }

    document.addEventListener('click', function(e) {
      const menu = document.getElementById('exportMenu');
      const btn = document.getElementById('btnExportar');
      if (!menu || !btn) return;
      if (!btn.contains(e.target) && !menu.contains(e.target)) {
        menu.classList.remove('show');
      }
    });
    
    function exportarCSV() {
      if (pedidosProcessados.length === 0) {
        mostrarErro('Nenhum dado dispon√≠vel para exportar. Processe um arquivo primeiro.');
        return;
      }
      
      try {
        // Cabe√ßalhos
        let csv = 'ID do Pedido;SKU;Subtotal;Reembolso;Cupom;Comiss√£o;Servi√ßo;Sobra;Meta;% vs Meta;Status\n';
        
        // Dados
        pedidosProcessados.forEach(pedido => {
          const status = pedido.meta ? 
            (pedido.percentual <= -10 ? 'Cr√≠tico' : 
             pedido.percentual <= -5 ? 'Aten√ß√£o' : 
             pedido.percentual >= 5 ? 'Bom' : 'Normal') : 'Sem meta';
          
          csv += `"${pedido.id}";"${pedido.sku}";"${pedido.subtotal.toFixed(2)}";"${pedido.reembolso.toFixed(2)}";"${pedido.cupom.toFixed(2)}";"${pedido.comissao.toFixed(2)}";"${pedido.servico.toFixed(2)}";"${pedido.sobra.toFixed(2)}";"${pedido.meta.toFixed(2)}";"${pedido.percentual.toFixed(2)}";"${status}"\n`;
        });
        
        const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
        saveAs(blob, `relatorio_sobras_${new Date().toISOString().slice(0,10)}.csv`);
        
        mostrarSucesso('Arquivo CSV exportado com sucesso!');
      } catch (error) {
        mostrarErro(`Erro ao exportar CSV: ${error.message}`);
        console.error("Erro ao exportar CSV:", error);
      }
    }
    async function carregarRegistrosFaturamento(idContainer = "listaFaturamento", idFiltroMes = "filtroMes") {
 let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('faturamento');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('faturamento');
      }
      const snap = await ref.get();
      const container = document.getElementById(idContainer);
      container.innerHTML = "";

      const filtroMes = document.getElementById(idFiltroMes)?.value;

      for (const docData of snap.docs) {
        if (filtroMes) {
          const [anoFiltro, mesFiltro] = filtroMes.split("-");
          const [anoData, mesData] = docData.id.split("-");
          if (anoFiltro !== anoData || mesFiltro !== mesData) continue;
        }

const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? docData.ref.parent.parent.id
          : usuarioLogado.uid;
        const subRef = db.collection(`uid/${ownerUid}/faturamento/${docData.id}/lojas`);
        const subSnap = await subRef.get();
                const { decryptString } = await import('./crypto.js');
        let bruto = 0, liquido = 0, qtd = 0;

        for (const sub of subSnap.docs) {
          const dataSub = sub.data();
          let d = dataSub;
          if (dataSub.encrypted) {
            try {
              const txt = await decryptString(dataSub.encrypted, getPassphrase() || usuarioLogado.uid);
              d = JSON.parse(txt);
            } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
          }
          bruto += d.valorBruto || 0;
          liquido += d.valorLiquido || 0;
          qtd += d.qtdVendas || 0;
        }

        const card = document.createElement("div");
        card.className = "bg-white rounded-2xl shadow-lg p-4 border border-gray-200 hover:shadow-xl transition";

        card.innerHTML = `
          <div class="text-sm text-gray-500 mb-2 flex items-center gap-2">
            <i class="fas fa-calendar-alt text-blue-600"></i>
            <span class="font-semibold">${docData.id}</span>
          </div>

          <div class="text-2xl font-bold text-blue-800 mb-1">üí∞ Bruto: R$ ${bruto.toLocaleString('pt-BR')}</div>
          <div class="text-xl font-semibold text-green-600 mb-1">üîª L√≠quido: R$ ${liquido.toLocaleString('pt-BR')}</div>
          <div class="text-base text-gray-600 mb-4">üõí Vendas: ${qtd}</div>

          <div class="flex justify-between items-center mt-4">
            <button onclick='mostrarDetalhesFaturamento("${docData.id}")'
              class="btn btn-outline">
              <i class="fas fa-search"></i> Ver Detalhes
            </button>
            <button onclick='excluirFaturamento("${docData.id}")'
              class="btn btn-outline">
              <i class="fas fa-trash-alt"></i> Excluir
            </button>
          </div>

          <div id="detalhes-${docData.id}" class="mt-3 text-sm text-gray-700" style="display:none;"></div>
        `;

        container.appendChild(card);
      }
    }

    async function mostrarDetalhesFaturamento(dataRef) {
      const detalhesEl = document.getElementById("detalhes-" + dataRef);
      if (detalhesEl.style.display === "block") {
        detalhesEl.style.display = "none";
        return;
      }

      detalhesEl.innerHTML = `<div class="text-sm text-gray-500">üîÑ Carregando...</div>`;
      detalhesEl.style.display = "block";

      const { decryptString } = await import('./crypto.js');
 let refs = [];
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        const q = await db.collectionGroup('faturamento')
          .where(firebase.firestore.FieldPath.documentId(), '==', dataRef)
          .get();
        q.forEach(doc => {
          refs.push(db.collection(`uid/${doc.ref.parent.parent.id}/faturamento/${dataRef}/lojas`));
        });
      } else {
        refs.push(db.collection(`uid/${usuarioLogado.uid}/faturamento/${dataRef}/lojas`));
      }
      let html = "";
 for (const r of refs) {
        const snap = await r.get();
        for (const doc of snap.docs) {
          let d = doc.data();
        if (d.encrypted) {
          try {
            const txt = await decryptString(d.encrypted, getPassphrase() || usuarioLogado.uid);
            d = JSON.parse(txt);
          } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
        }
        const loja = d.loja || "Desconhecida";
        const bruto = d.valorBruto?.toLocaleString("pt-BR") || "0,00";
        const liquido = d.valorLiquido?.toLocaleString("pt-BR") || "0,00";
        const vendas = d.qtdVendas || 0;

        html += `
          <div class="mt-1 text-sm text-gray-800 border-t pt-1">
            <strong>${loja}</strong>: Bruto R$ ${bruto} | L√≠quido R$ ${liquido} | Vendas: ${vendas}
          </div>
        `;
       }
      }

      detalhesEl.innerHTML = html;
    }

    async function excluirFaturamento(data) {
        if (!confirm(`Tem certeza que deseja excluir o faturamento do dia ${data}?`)) return;
        if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
          const snap = await db.collectionGroup('faturamento')
            .where(firebase.firestore.FieldPath.documentId(), '==', data)
            .get();
          for (const doc of snap.docs) {
            await db.collection(`uid/${doc.ref.parent.parent.id}/faturamento`).doc(data).delete();
          }
        } else {
          await db.collection('uid').doc(usuarioLogado.uid).collection('faturamento').doc(data).delete();
        }
        mostrarSucesso("Registro exclu√≠do com sucesso.");
        carregarRegistrosFaturamento();
      }

    function exportarJSON() {
      if (pedidosProcessados.length === 0) {
        mostrarErro('Nenhum dado dispon√≠vel para exportar. Processe um arquivo primeiro.');
        return;
      }
      
      try {
        const data = {
          geradoEm: new Date().toISOString(),
          pedidos: pedidosProcessados,
          resumo: {
            totalSobra: pedidosProcessados.reduce((sum, p) => sum + p.sobra, 0),
            totalMeta: pedidosProcessados.reduce((sum, p) => sum + (p.meta || 0), 0)
          }
        };
        
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
        saveAs(blob, `relatorio_sobras_${new Date().toISOString().slice(0,10)}.json`);
        
        mostrarSucesso('Arquivo JSON exportado com sucesso!');
      } catch (error) {
        mostrarErro(`Erro ao exportar JSON: ${error.message}`);
        console.error("Erro ao exportar JSON:", error);
      }
    }
    window.analisarSobrasComIA = async function analisarSobrasComIA() {
      try {
        const linhas = document.querySelectorAll("#tabelaSobras tbody tr");
        let dados = [];

        linhas.forEach(linha => {
          const colunas = linha.querySelectorAll("td");
          if (colunas.length >= 5) {
            dados.push({
              sku: colunas[0].innerText.trim(),
              nome: colunas[1].innerText.trim(),
              vendido: parseInt(colunas[2].innerText) || 0,
              sobra: parseInt(colunas[3].innerText) || 0,
              data: colunas[4].innerText.trim()
            });
          }
        });

        const prompt = `
    Voc√™ √© um especialista em controle de estoque e sobras da Shopee.

    Receber√° uma lista com SKUs, nomes, vendidos e sobras.

    Analise:
    üîπ 1. Valide se a sobra registrada faz sentido
    üîπ 2. Detecte padr√µes incomuns (ex: sobra alta sem venda)
    üîπ 3. Gere resumo por SKU com observa√ß√µes
    üîπ 4. Sugira a√ß√µes (ex: revisar, repor, ignorar)

    Dados:
    ${JSON.stringify(dados, null, 2)}
    `;

        const resposta = await consultarDeepSeek(prompt);
        document.getElementById("resultadoIA").innerText = resposta;
      } catch (erro) {
        console.error("Erro IA sobras:", erro);
        document.getElementById("resultadoIA").innerText = "Erro ao analisar sobras com IA.";
      }
   };
    async function analisarSobrasIA() {
      const prompt = `
    Sou um sistema de controle de sobras da Shopee. Com base nos dados abaixo, analise se os SKUs est√£o performando bem, identifique padr√µes incomuns e sugira a√ß√µes como promo√ß√µes, reposi√ß√£o ou aten√ß√£o especial.

    Dados:
    ${document.getElementById("dadosSobrasIA").value}

    Gere um resumo inteligente com insights pr√°ticos.
    `;

      document.getElementById("resultadoIA").innerHTML = "‚åõ Analisando com IA...";
      
      try {
        const resposta = await fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ pergunta: prompt })
        });

        const data = await resposta.json();
        const output = data.choices?.[0]?.message?.content || data.resposta || "‚ö†Ô∏è Resposta n√£o recebida.";

        document.getElementById("resultadoIA").innerHTML = output;
      } catch (error) {
        document.getElementById("resultadoIA").innerHTML = "‚ùå Erro ao consultar IA: " + error.message;
        console.error("Erro IA:", error);
        updateConnectionStatus(false);
      }
    }
    async function carregarControleVendas() {
      const container = document.getElementById("listaControleVendas");
      const resumoContainer = document.getElementById("resumoMensalVendas");
      const projecaoContainer = document.getElementById("cardsProjecao");
      const filtroMes = document.getElementById("filtroMesVendas")?.value;
      container.innerHTML = "üîÑ Carregando...";
      if (resumoContainer) resumoContainer.innerHTML = "";
      if (projecaoContainer) projecaoContainer.innerHTML = "üîÑ Carregando...";

      let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('skusVendidos');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('skusVendidos');
      }
      const snap = await ref.get();

      if (projecaoContainer) {
        const hoje = new Date();
        const proxMes = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 1);
        const anoMesPrev = proxMes.toISOString().slice(0, 7);
        try {
          if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
            const prevSnap = await db.collectionGroup('previsoes')
              .where(firebase.firestore.FieldPath.documentId(), '==', anoMesPrev)
              .get();
            const totalPrev = {};
            prevSnap.forEach(doc => {
              const dados = doc.data();
              if (dados.skus) {
                Object.entries(dados.skus).forEach(([sku, info]) => {
                  totalPrev[sku] = (totalPrev[sku] || 0) + (info.total || 0);
                });
              }
            });
            if (Object.keys(totalPrev).length) {
              projecaoContainer.innerHTML = Object.entries(totalPrev)
                .map(([sku, total]) => `<div class="bg-yellow-100 text-yellow-800 p-4 rounded shadow flex justify-between"><span>${sku}</span><span class="font-bold">${total.toFixed(0)}</span></div>`)
                .join('');
            } else {
              projecaoContainer.innerHTML = '<p class="text-gray-500">Nenhuma previs√£o dispon√≠vel.</p>';
            }
          } else {
            const prevDoc = await db.collection('uid').doc(usuarioLogado.uid).collection('previsoes').doc(anoMesPrev).get();
            if (prevDoc.exists) {
              const dados = prevDoc.data();
              projecaoContainer.innerHTML = Object.entries(dados.skus || {})
                .map(([sku, info]) => `<div class="bg-yellow-100 text-yellow-800 p-4 rounded shadow flex justify-between"><span>${sku}</span><span class="font-bold">${(info.total || 0).toFixed(0)}</span></div>`)
                .join('');
            } else {
              projecaoContainer.innerHTML = '<p class="text-gray-500">Nenhuma previs√£o dispon√≠vel.</p>';
            }
          }
        } catch (err) {
          console.error('Erro ao carregar previs√£o', err);
          projecaoContainer.innerHTML = '<p class="text-red-500">Erro ao carregar previs√£o.</p>';
        }
      }

      container.innerHTML = "";
      const totaisSku = {};

      for (const doc of snap.docs) {
        const dataDoc = doc.id; // Ex: 2025-07-21
        if (filtroMes) {
          const [anoFiltro, mesFiltro] = filtroMes.split("-");
          const [anoDoc, mesDoc] = dataDoc.split("-");
          if (anoFiltro !== anoDoc || mesFiltro !== mesDoc) continue;
        }

 const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? doc.ref.parent.parent.id
          : usuarioLogado.uid;
        const listaRef = db.collection(`uid/${ownerUid}/skusVendidos/${dataDoc}/lista`);
        const listaSnap = await listaRef.get();
        if (listaSnap.empty) continue;

        let htmlSKUs = "";
        let totalDia = 0;

        listaSnap.forEach(docSKU => {
          const { sku, total, loja } = docSKU.data();
          const skuKey = sku || docSKU.id;
          totalDia += total || 0;
          htmlSKUs += `
      <div class="text-sm text-gray-700">
        <strong>${skuKey}</strong> (${loja || "-"}) ‚Äî ${total || 0} unid.
      </div>`;
          totaisSku[skuKey] = (totaisSku[skuKey] || 0) + (total || 0);
        });

        const card = document.createElement("div");
        card.className = "bg-white rounded-lg shadow p-4 border border-gray-200";
        card.innerHTML = `
          <div class="text-center font-bold bg-blue-100 text-blue-800 py-2 rounded mb-2">${dataDoc}</div>
          <div class="mb-2 text-sm text-gray-600">üßæ Total do dia: <strong>${totalDia}</strong> unidades</div>
          ${htmlSKUs}
          <div class="text-right mt-2">
        <button onclick="verDetalhesDia('${dataDoc}')" class="text-blue-600 text-sm underline">üîç Ver mais</button>
      </div>
        `;
        container.appendChild(card);
      }

      if (container.innerHTML === "") {
        container.innerHTML = `<p class="text-gray-500">Nenhum dado encontrado para o per√≠odo selecionado.</p>`;
      }
      if (resumoContainer) {
        if (Object.keys(totaisSku).length) {
          const cards = Object.entries(totaisSku)
            .sort((a, b) => b[1] - a[1])
            .map(([sku, total]) =>
              `<div class="bg-white rounded-lg shadow p-4 border border-gray-200 flex justify-between"><span>${sku}</span><span class="font-bold">${total}</span></div>`
            ).join("");
          resumoContainer.innerHTML = cards;
        } else {
          resumoContainer.innerHTML = `<p class="text-gray-500">Nenhum dado encontrado para o per√≠odo selecionado.</p>`;
        }
      }
    }

    async function carregarSobras() {
      await tabsLoaded;
      if (!usuarioLogado.uid) {
        console.error('Usu√°rio n√£o autenticado');
        return;
      }
      const tbody = document.getElementById('listaSobras');
      if (tbody) tbody.innerHTML = '<tr><td colspan="9">Carregando...</td></tr>';
      try {
        const pedidos = [];
        const addPedidos = (snap, usuario) => {
          snap.forEach(doc => pedidos.push({ usuario, ...doc.data() }));
        };
        const snap = await db.collection('uid').doc(usuarioLogado.uid).collection('pedidosErrados').get();
        addPedidos(snap, usuarioLogado.email || usuarioLogado.uid);
        const respSnap = await db.collection('usuarios').where('responsavelFinanceiroEmail', '==', usuarioLogado.email).get();
        for (const docSnap of respSnap.docs) {
          const nome = docSnap.data().nome || docSnap.data().email || docSnap.id;
          const errSnap = await db.collection('uid').doc(docSnap.id).collection('pedidosErrados').get();
          addPedidos(errSnap, nome);
        }
        if (tbody) {
          if (!pedidos.length) {
            tbody.innerHTML = '<tr><td colspan="9" class="text-center text-gray-500">Sem pedidos</td></tr>';
            return;
          }
          const format = v => Number(v || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 });
          tbody.innerHTML = '';
          pedidos.forEach(d => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${d.usuario || ''}</td><td>${d.dia || ''}</td><td>${d.loja || d.shop || ''}</td><td>${d.pedido || d.idPedido || d.numeroPedido || ''}</td><td>${d.sku || ''}</td><td>${d.quantidade || d.qtd || 0}</td><td>R$ ${format(d.subtotal)}</td><td>R$ ${format(d.sobraReal || d.totalLiquido)}</td><td>R$ ${format(d.sobraEsperada || d.metaEsperada)}</td>`;
            tbody.appendChild(tr);
          });
        }
      } catch (e) {
        console.error('Erro ao carregar sobras', e);
        if (tbody) tbody.innerHTML = '<tr><td colspan="9" class="text-red-500">Erro ao carregar dados</td></tr>';
      }
    }

    async function carregarPrevisao() {
      await tabsLoaded;
      const selectSku = document.getElementById('filtroSkuPrevisao');
      const cards = document.getElementById('cardsPrevisao');
      if (!selectSku || !cards) return;
      cards.innerHTML = 'üîÑ Carregando...';
      const hoje = new Date();
      const proxMes = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 1);
      const anoMes = proxMes.toISOString().slice(0,7);
      const doc = await db.collection('uid').doc(usuarioLogado.uid).collection('previsoes').doc(anoMes).get();
      if (doc.exists) {
        previsaoDados = doc.data() || {};
        const skus = Object.keys(previsaoDados.skus || {});
        selectSku.innerHTML = '<option value="todos">Todos</option>' + skus.map(s => `<option value="${s}">${s}</option>`).join('');
        cards.innerHTML = '';
        renderizarPrevisao();
        renderizarTopSkus();
      } else {
        previsaoDados = { skus: {} };
        selectSku.innerHTML = '<option value="todos">Todos</option>';
        cards.innerHTML = 'üîÑ Gerando previs√£o inicial...';
        await gerarPrevisao({ topN: 5, silencioso: true });
      }
    }

    function renderizarPrevisao() {
      const selectSku = document.getElementById('filtroSkuPrevisao');
      const sku = selectSku?.value || 'todos';
      const cards = document.getElementById('cardsPrevisao');
      const tabela = document.getElementById('tabelaPrevisao');
      const ctx = document.getElementById('graficoPrevisao')?.getContext('2d');
      if (!cards || !tabela || !ctx) return;

      let diario = {};
      let totalBase = 0;
      if (sku === 'todos') {
        for (const info of Object.values(previsaoDados.skus || {})) {
          totalBase += info.total || 0;
          for (const [data, val] of Object.entries(info.diario || {})) {
            diario[data] = (diario[data] || 0) + val;
          }
        }
      } else if (previsaoDados.skus && previsaoDados.skus[sku]) {
        const info = previsaoDados.skus[sku];
        totalBase = info.total || 0;
        diario = info.diario || {};
      }

      const pess = totalBase * 0.85;
      const otm = totalBase * 1.15;
      cards.innerHTML = `
        <div class="bg-red-100 text-red-800 p-4 rounded shadow text-center">
          <div class="font-bold">Pessimista</div><div>${pess.toFixed(0)}</div>
        </div>
        <div class="bg-blue-100 text-blue-800 p-4 rounded shadow text-center">
          <div class="font-bold">Base</div><div>${totalBase.toFixed(0)}</div>
        </div>
        <div class="bg-green-100 text-green-800 p-4 rounded shadow text-center">
          <div class="font-bold">Otimista</div><div>${otm.toFixed(0)}</div>
        </div>`;

      const labels = Object.keys(diario).sort();
      const dados = labels.map(d => diario[d]);
      if (graficoPrevisao) graficoPrevisao.destroy();
      graficoPrevisao = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{ label: 'Previs√£o di√°ria', data: dados, borderColor: '#2563eb', backgroundColor: 'rgba(37,99,235,0.3)', tension: 0.2 }] },
        options: { responsive: true, maintainAspectRatio: false }
      });

      tabela.innerHTML = `
        <table class="min-w-full text-sm text-left">
          <thead><tr><th class="px-2 py-1 border">Data</th><th class="px-2 py-1 border">Qtde</th></tr></thead>
          <tbody>
            ${labels.map(d => `<tr><td class="px-2 py-1 border">${d}</td><td class="px-2 py-1 border">${diario[d].toFixed(0)}</td></tr>`).join('')}
          </tbody>
        </table>`;
    }

    function renderizarTopSkus() {
      const container = document.getElementById('topSkusPrevisao');
      if (!container) return;
      const dadosSkus = Object.entries(previsaoDados.skus || {});
      if (!dadosSkus.length) {
        container.innerHTML = '<p class="text-gray-500">Nenhuma previs√£o dispon√≠vel.</p>';
        return;
      }

      const cenarios = [
        { titulo: 'Pessimista', fator: 0.85 },
        { titulo: 'Base', fator: 1 },
        { titulo: 'Otimista', fator: 1.15 }
      ];

      const tabelas = cenarios.map(c => {
        const lista = dadosSkus
          .map(([sku, info]) => {
            const quantidade = (info.total || 0) * c.fator;
            const preco = produtos[sku] || 0;
            const sobraUnit = metas[sku]?.valor || 0;
            const bruto = quantidade * preco;
            const sobra = quantidade * sobraUnit;
            return { sku, quantidade, bruto, sobra };
          })
          .sort((a, b) => b.quantidade - a.quantidade)
          .slice(0, 5);

        if (!lista.length) {
          return '<p class="text-gray-500">Nenhuma previs√£o dispon√≠vel.</p>';
        }

        const linhas = lista.map(item => `
            <tr>
              <td class="px-2 py-1 border">${item.sku}</td>
              <td class="px-2 py-1 border">${item.quantidade.toFixed(0)}</td>
              <td class="px-2 py-1 border">R$ ${item.bruto.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
              <td class="px-2 py-1 border">R$ ${item.sobra.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
            </tr>`).join('');

        return `
          <div class="overflow-x-auto">
            <h4 class="font-bold mb-2 text-center">Top 5 SKUs proje√ß√£o ${c.titulo}</h4>
            <table class="min-w-full text-sm text-left">
              <thead>
                <tr>
                  <th class="px-2 py-1 border">SKU</th>
                  <th class="px-2 py-1 border">Quantidade</th>
                  <th class="px-2 py-1 border">Bruto Esperado<br>(Valor de venda)</th>
                  <th class="px-2 py-1 border">Sobra Esperada<br>(Sobra esperada x quantidade)</th>
                </tr>
              </thead>
              <tbody>
                ${linhas}
              </tbody>
            </table>
          </div>`;
      }).join('');

      container.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-3 gap-4">${tabelas}</div>`;
    }

    function gerarDatas(qtd, endDate = new Date()) {
      const datas = [];
      for (let i = qtd; i > 0; i--) {
        const d = new Date(endDate);
        d.setDate(d.getDate() - i);
        datas.push(d.toISOString().slice(0,10));
      }
      return datas;
    }

    function calcularBeta(arr) {
      const n = arr.length;
      const xMean = (n + 1) / 2;
      const yMean = arr.reduce((a, b) => a + b, 0) / n;
      let num = 0, den = 0;
      for (let i = 0; i < n; i++) {
        num += (i + 1 - xMean) * (arr[i] - yMean);
        den += Math.pow(i + 1 - xMean, 2);
      }
      return den ? num / den : 0;
    }

    function clamp(v, min, max) {
      return Math.min(max, Math.max(min, v));
    }

    function winsorize(arr, low = 0.05, high = 0.95) {
      const sorted = [...arr].sort((a, b) => a - b);
      const n = sorted.length;
      const lowVal = sorted[Math.floor(n * low)];
      const highVal = sorted[Math.ceil(n * high) - 1];
      return arr.map(v => clamp(v, lowVal, highVal));
    }

    function percentile(arr, p) {
      if (!arr.length) return 0;
      const sorted = [...arr].sort((a, b) => a - b);
      const idx = (sorted.length - 1) * p;
      const lower = Math.floor(idx);
      const upper = Math.ceil(idx);
      const weight = idx - lower;
      return sorted[lower] * (1 - weight) + (sorted[upper] || sorted[lower]) * weight;
    }

    async function gerarPrevisao(opcoes = {}) {
      const { topN, silencioso } = opcoes;
      const btn = document.getElementById('btnGerarPrevisao');
      if (btn) { btn.disabled = true; btn.innerText = 'Gerando...'; }
      const hoje = new Date();
      const proxMes = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 1);
      const anoMes = proxMes.toISOString().slice(0,7);
      const diasProxMes = new Date(proxMes.getFullYear(), proxMes.getMonth()+1, 0).getDate();
      const datas30 = gerarDatas(30, hoje);
      const datas90 = gerarDatas(90, hoje);
      const ref = db.collection(`uid/${usuarioLogado.uid}/skusVendidos`);
      const snap = await ref.get();
      const serieSkus = {};

      for (const doc of snap.docs) {
        const dataDoc = doc.id;
        if (!datas90.includes(dataDoc)) continue;
        const listaSnap = await doc.ref.collection('lista').get();
        for (const skuDoc of listaSnap.docs) {
          const { sku, total } = skuDoc.data();
          const skuKey = sku || skuDoc.id;
          if (!serieSkus[skuKey]) serieSkus[skuKey] = {};
          serieSkus[skuKey][dataDoc] = (serieSkus[skuKey][dataDoc] || 0) + (total || 0);
        }
      }

      let skuKeys = Object.keys(serieSkus);
      if (topN) {
        const totais = skuKeys.map(sku => ({
          sku,
          total: datas30.reduce((s, d) => s + (serieSkus[sku][d] || 0), 0)
        }));
        skuKeys = totais.sort((a, b) => b.total - a.total).slice(0, topN).map(t => t.sku);
      }

      const previsao = { skus: {}, totalGeral: 0 };
      for (const sku of skuKeys) {
        const serie = serieSkus[sku] || {};
        const arr90 = datas90.map(d => serie[d] || 0);
        const arr90w = winsorize(arr90, 0.05, 0.95);
        const arr30 = arr90w.slice(-30);
        const arr7 = arr30.slice(-7);
        const avg30 = arr30.reduce((a,b)=>a+b,0) / arr30.length;
        const avg7 = arr7.reduce((a,b)=>a+b,0) / arr7.length;

        let w30 = 0.6;
        let w7 = 0.4;
        const nDados = Object.keys(serie).length;
        if (nDados < 30) {
          const f30 = Math.min(nDados / 30, 1);
          const f7 = Math.min(nDados / 7, 1);
          w30 *= f30;
          w7 *= f7;
          const wsum = w30 + w7;
          if (wsum > 0) { w30 /= wsum; w7 /= wsum; }
        }
        const base = w30 * avg30 + w7 * avg7;

        let beta = 0;
        if (nDados >= 14) beta = calcularBeta(arr30);
        const lowBase = avg30 < 1 && avg7 < 1;
        if (lowBase) beta = 0;

        const globalMean = arr90w.reduce((s,v)=>s+v,0) / arr90w.length;
        const weeks = Math.min(12, Math.floor(nDados / 7));
        let lambda = Math.min(1, weeks / 12);
        if (nDados < 7 || lowBase) lambda = 0;
        const fatores = {};
        for (let w=0; w<7; w++) {
          const vals = datas90
            .map((d,i)=>({d, v: arr90w[i]}))
            .filter(({d})=>new Date(d).getDay()===w)
            .map(({v})=>v);
          const m = vals.length ? vals.reduce((a,b)=>a+b,0)/vals.length : 0;
          const fatorWd = globalMean ? m/globalMean : 1;
          const saz = 1 + lambda * (fatorWd - 1);
          fatores[w] = clamp(saz, 0.85, 1.20);
        }

        const p95 = percentile(arr90w, 0.95);
        const diario = {};
        let total = 0;
        for (let i=1; i<=diasProxMes; i++) {
          const d = new Date(proxMes.getFullYear(), proxMes.getMonth(), i);
          const wd = d.getDay();
          const trendRaw = beta * i;
          const trend = clamp(trendRaw * 0.5, -0.2*base/30, 0.2*base/30);
          const saz = fatores[wd] || 1;
          let val = (base + trend) * saz;
          val = clamp(Math.round(Math.max(0, val)), 0, Math.round(p95 * 1.2));
          const ds = d.toISOString().slice(0,10);
          diario[ds] = val;
          total += val;
        }
        previsao.skus[sku] = { diario, total, p95 };
        previsao.totalGeral += total;
      }

      await db.collection('uid').doc(usuarioLogado.uid).collection('previsoes').doc(anoMes).set(previsao);
      if (btn) { btn.disabled = false; btn.innerHTML = '<i class="fas fa-sync-alt"></i> Gerar previs√£o'; }
      if (!silencioso) Swal.fire('Sucesso','Previs√£o gerada!','success');
      carregarPrevisao();
      carregarControleVendas();
    }
    window.verDetalhesDia = async function (dataDoc) {
let uids = [];
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        const q = await db.collectionGroup('skusVendidos')
          .where(firebase.firestore.FieldPath.documentId(), '==', dataDoc)
          .get();
        q.forEach(doc => uids.push(doc.ref.parent.parent.id));
      } else {
        uids.push(usuarioLogado.uid);
      }

      const agrupadoPorLoja = {};
      let sobraEsperada = 0;
      let valorLiquidoTotal = 0;

      for (const uid of uids) {
        const ref = db.collection(`uid/${uid}/skusVendidos/${dataDoc}/lista`);
        const snap = await ref.get();
        for (const doc of snap.docs) {
          const { sku, total, loja, valorLiquido: valorSku } = doc.data();
          if (!agrupadoPorLoja[loja]) agrupadoPorLoja[loja] = [];

          let custo = 0;
          try {
            const produtosRef = db.collection('uid').doc(uid).collection('produtos');
            const querySnap = await produtosRef.where('sku', '==', sku).limit(1).get();
            if (!querySnap.empty) {
              const dados = querySnap.docs[0].data();
              custo = Number(dados.custo || 0);

            }
          } catch (e) {
            console.warn(`Erro ao buscar custo do SKU ${sku}:`, e);
          }
          sobraEsperada += (total || 0) * custo;
          valorLiquidoTotal += Number(valorSku || 0);
          agrupadoPorLoja[loja].push({ sku, total, custo, valorLiquido: valorSku || 0 });
        }
      }

      // üßæ Montar HTML
      let html = `<strong>üìÖ Detalhes de ${dataDoc}</strong><br><br>`;
      for (const loja in agrupadoPorLoja) {
        html += `<strong>üè™ Loja: ${loja}</strong>`;
        html += `<table style="width:100%; border-collapse: collapse; margin: 8px 0;">
          <thead>
            <tr style="background:#f0f0f0;">
              <th style="border:1px solid #ddd; padding:4px;">SKU</th>
              <th style="border:1px solid #ddd; padding:4px;">Unidades</th>
              <th style="border:1px solid #ddd; padding:4px;">Sobra Esperada</th>
              <th style="border:1px solid #ddd; padding:4px;">Valor L√≠quido</th>
            </tr>
          </thead>
          <tbody>`;
        agrupadoPorLoja[loja].forEach(({ sku, total, custo, valorLiquido }) => {
          const sobraItem = (total || 0) * (custo || 0);
          html += `<tr>
            <td style="border:1px solid #ddd; padding:4px;">${sku}</td>
            <td style="border:1px solid #ddd; padding:4px;">${total}</td>
            <td style="border:1px solid #ddd; padding:4px;">R$ ${sobraItem.toFixed(2)}</td>
            <td style="border:1px solid #ddd; padding:4px;">R$ ${(valorLiquido || 0).toFixed(2)}</td>
          </tr>`;
        });
        html += `</tbody></table>`;
      }

      html += `<hr><strong>üì¶ Sobra Esperada:</strong> R$ ${sobraEsperada.toFixed(2)}<br>`;
      html += `<strong>üí∞ Valor L√≠quido Real:</strong> R$ ${valorLiquidoTotal.toFixed(2)}<br>`;

      Swal.fire({
        title: 'Detalhamento por Loja',
        html: html,
        icon: 'info',
        confirmButtonText: 'Fechar'
      });
    };

    async function exportarVendasMes() {
      const filtroMes = document.getElementById('filtroMesVendas')?.value;
      if (!filtroMes) {
        alert('Selecione um m√™s para exportar.');
        return;
      }

      let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('skusVendidos');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('skusVendidos');
      }
      const snap = await ref.get();

      const dados = [];
      const resumo = {};

      for (const doc of snap.docs) {
        const dataDoc = doc.id;
        const [anoDoc, mesDoc] = dataDoc.split('-');
        const [anoFiltro, mesFiltro] = filtroMes.split('-');
        if (anoDoc !== anoFiltro || mesDoc !== mesFiltro) continue;

        const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? doc.ref.parent.parent.id
          : usuarioLogado.uid;
        const listaSnap = await db.collection(`uid/${ownerUid}/skusVendidos/${dataDoc}/lista`).get();
        for (const skuDoc of listaSnap.docs) {
          const { sku, total, loja, valorLiquido } = skuDoc.data();
          let custo = 0;
          try {
            const produtosRef = db.collection('uid').doc(ownerUid).collection('produtos');
            const querySnap = await produtosRef.where('sku', '==', sku).limit(1).get();
            if (!querySnap.empty) {
              const dadosProd = querySnap.docs[0].data();
              custo = Number(dadosProd.custo || 0);
            }
          } catch (e) {
            console.warn(`Erro ao buscar custo do SKU ${sku}:`, e);
          }

          const sobraEsperada = (total || 0) * (custo || 0);
          const sobraReal = Number(valorLiquido || 0);
          const chave = sku || skuDoc.id;

          dados.push({
            Data: dataDoc,
            Loja: loja || '-',
            SKU: chave,
            Unidades: total || 0,
            SobraEsperada: sobraEsperada,
            SobraReal: sobraReal
          });

          if (!resumo[chave]) resumo[chave] = { sku: chave, total: 0, prejuizo: 0 };
          resumo[chave].total += total || 0;
          resumo[chave].prejuizo += (sobraEsperada - sobraReal);
        }
      }

      if (!dados.length) {
        alert('Nenhum dado de vendas encontrado para o m√™s selecionado.');
        return;
      }

      const itemsResumo = Object.values(resumo);
      const maiorEntrada = itemsResumo.reduce((a, b) => (b.total > a.total ? b : a));
      const menorEntrada = itemsResumo.reduce((a, b) =>
        (b.total > 0 && b.total < a.total ? b : a), { total: Infinity });
      const maiorPrejuizo = itemsResumo.reduce((a, b) => (b.prejuizo > a.prejuizo ? b : a));

      const resumoSheet = [
        { Resumo: 'Maior entrada', SKU: maiorEntrada.sku, Unidades: maiorEntrada.total },
        { Resumo: 'Menor entrada', SKU: menorEntrada.sku, Unidades: menorEntrada.total },
        { Resumo: 'Maior preju√≠zo', SKU: maiorPrejuizo.sku, Valor: maiorPrejuizo.prejuizo.toFixed(2) }
      ];

      const wsDados = XLSX.utils.json_to_sheet(dados);
      const wsResumo = XLSX.utils.json_to_sheet(resumoSheet);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, wsDados, 'Vendas');
      XLSX.utils.book_append_sheet(wb, wsResumo, 'Resumo');
      XLSX.writeFile(wb, `vendas_${filtroMes}.xlsx`);
    }

    async function exportarFaturamentoExcel() {
 let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('faturamento');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('faturamento');
      }
      const snap = await ref.get();
      const { decryptString } = await import('./crypto.js');

      for (const docData of snap.docs) {
 const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? docData.ref.parent.parent.id
          : usuarioLogado.uid;
        const subRef = db.collection(`uid/${ownerUid}/faturamento/${docData.id}/lojas`);
        const subSnap = await subRef.get();
       for (const sub of subSnap.docs) {
          let d = sub.data();
          if (d.encrypted) {
            try {
              const txt = await decryptString(d.encrypted, getPassphrase() || usuarioLogado.uid);
              d = JSON.parse(txt);
            } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
          }
          dataExport.push({
            Data: docData.id,
            Loja: d.loja || "Desconhecida",
            Bruto: d.valorBruto || 0,
            Taxas: d.taxasPlataforma || 0,
            L√≠quido: d.valorLiquido || 0,
            Vendas: d.qtdVendas || 0
          });
       }
      }

      if (dataExport.length === 0) {
        alert("Nenhum dado de faturamento encontrado.");
        return;
      }

      const ws = XLSX.utils.json_to_sheet(dataExport);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Faturamento");
      XLSX.writeFile(wb, "faturamento.xlsx");
    }
    
    async function carregarAcompanhamento() {
      const tbody = document.querySelector('#tabelaAcompanhamento tbody');
      const resumoEl = document.getElementById('resumoAcompanhamento');
      tbody.innerHTML = '<tr><td colspan="4">üîÑ Carregando...</td></tr>';
      resumoEl.innerHTML = '';
 const metaBrutoDiario = parseFloat(localStorage.getItem('metaBrutoDiario')) || 0;
      const metaLiquidoDiario = parseFloat(localStorage.getItem('metaLiquidoDiario')) || 0;
     const metaBrutoInput = document.getElementById('metaBrutoDiario');
      if (metaBrutoInput) metaBrutoInput.value = metaBrutoDiario || '';
      const metaLiquidoInput = document.getElementById('metaLiquidoDiario');
      if (metaLiquidoInput) metaLiquidoInput.value = metaLiquidoDiario || '';
      
    let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('faturamento');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('faturamento');
      }
      const snap = await ref.get();
      const { decryptString } = await import('./crypto.js');

      const filtroMes = document.getElementById('filtroMesAcompanhamento')?.value;
      let dados = [];
            dadosAcompanhamento = [];
      sobraPorSku = {};
      resumoSku = {};
      let totalBruto = 0, totalLiquido = 0, totalVendas = 0, totalSobra = 0;
      let totalSaques = 0, totalComissao = 0;

      for (const doc of snap.docs) {
        if (filtroMes) {
          const [anoFiltro, mesFiltro] = filtroMes.split('-');
          const [ano, mes] = doc.id.split('-');
          if (ano !== anoFiltro || mes !== mesFiltro) continue;
        }

  const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? doc.ref.parent.parent.id
          : usuarioLogado.uid;
        const subRef = db.collection(`uid/${ownerUid}/faturamento/${doc.id}/lojas`);
        const subSnap = await subRef.get();
        let bruto = 0, liquido = 0, vendas = 0;
         for (const s of subSnap.docs) {
          let d = s.data();
          if (d.encrypted) {
            try {
              const txt = await decryptString(d.encrypted, getPassphrase() || usuarioLogado.uid);
              d = JSON.parse(txt);
            } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
          }
          bruto += d.valorBruto || 0;
          liquido += d.valorLiquido || 0;
          vendas += d.qtdVendas || 0;
        }

        let sobraDia = 0;
        try {
           let listaRef = db.collection(`uid/${ownerUid}/skusVendidos/${doc.id}/lista`);

          const listaSnap = await listaRef.get();
          listaSnap.forEach(item => {
            const { sku, total, valorLiquido } = item.data();
            const custo = Number(produtos[sku] || 0);
            const quantidade = total || 0;
            const valor = quantidade * custo;
            const liquidoSku = valorLiquido || 0;
            sobraDia += valor;
            sobraPorSku[sku] = (sobraPorSku[sku] || 0) + valor;
            resumoSku[sku] = resumoSku[sku] || { vendas: 0, sobra: 0, liquido: 0 };
            resumoSku[sku].vendas += quantidade;
            resumoSku[sku].sobra += valor;
            resumoSku[sku].liquido += liquidoSku;
          });
        } catch (e) {
          console.warn('Erro ao calcular sobra esperada do dia', e);
        }

        dados.push({ data: doc.id, bruto, liquido, vendas, sobra: sobraDia });
        totalBruto += bruto;
        totalLiquido += liquido;
        totalVendas += vendas;
        totalSobra += sobraDia;
      }

      try {
        let refSaques;
        if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
          refSaques = db.collectionGroup('saques');
        } else {
          refSaques = db.collection('uid').doc(usuarioLogado.uid).collection('saques');
        }
        const snapSaques = await refSaques.get();
        for (const docS of snapSaques.docs) {
          if (filtroMes) {
            const [anoFiltro, mesFiltro] = filtroMes.split('-');
            const [anoS, mesS] = docS.id.split('-');
            if (anoS !== anoFiltro || mesS !== mesFiltro) continue;
          }
          let dadosSaque = docS.data();
          if (dadosSaque.encrypted) {
            try {
              const txt = await decryptString(dadosSaque.encrypted, getPassphrase() || `chave-${dadosSaque.uid || usuarioLogado.uid}`);
              dadosSaque = JSON.parse(txt);
            } catch (e) {
              console.error('Erro ao descriptografar saque', e);
              continue;
            }
          }
          totalSaques += dadosSaque.valorTotal || dadosSaque.valor || 0;
          const ownerUidSaques = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase()) ? docS.ref.parent.parent.id : usuarioLogado.uid;
          try {
            const subRefSaque = db.collection(`uid/${ownerUidSaques}/saques/${docS.id}/lojas`);
            const subSnapSaque = await subRefSaque.get();
            for (const lojaDoc of subSnapSaque.docs) {
              let dadosLoja = lojaDoc.data();
              if (dadosLoja.encrypted) {
                try {
                  const txtLoja = await decryptString(dadosLoja.encrypted, getPassphrase() || `chave-${dadosSaque.uid || ownerUidSaques}`);
                  dadosLoja = JSON.parse(txtLoja);
                } catch (e) {
                  console.error('Erro ao descriptografar loja saque', e);
                  continue;
                }
              }
              const valorLoja = parseFloat(dadosLoja.valor) || 0;
              const comissaoPct = parseFloat(dadosLoja.comissao) || 0;
              if (comissaoPct) totalComissao += (valorLoja * comissaoPct / 100);
            }
          } catch (e) {
            console.error('Erro ao carregar comiss√£o dos saques', e);
          }
        }
      } catch (e) {
        console.error('Erro ao carregar saques', e);
      }
      totalSaquesAcompanhamento = totalSaques;
      totalComissaoAcompanhamento = totalComissao;

      tbody.innerHTML = '';
      dados.sort((a,b) => a.data.localeCompare(b.data));
      dadosAcompanhamento = dados.slice();
      dados.forEach(d => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${d.data}</td><td>R$ ${d.bruto.toLocaleString('pt-BR')}</td><td>R$ ${d.liquido.toLocaleString('pt-BR')}</td><td>${d.vendas}</td>`;
            if ((metaBrutoDiario && d.bruto < metaBrutoDiario) || (metaLiquidoDiario && d.liquido < metaLiquidoDiario)) {
          tr.classList.add('abaixo-meta');
        }
        tbody.appendChild(tr);
      });

 // Calcula totais a partir de dadosAcompanhamento
      const totais = dadosAcompanhamento.reduce((acc, item) => {
        acc.bruto += item.bruto || 0;
        acc.liquido += item.liquido || 0;
        acc.vendas += item.vendas || 0;
        acc.sobra += item.sobra || 0;
        return acc;
      }, { bruto: 0, liquido: 0, vendas: 0, sobra: 0 });
      const ticket = totais.vendas ? totais.liquido / totais.vendas : 0;
const dias = dadosAcompanhamento.length;
      const totalMetaBruto = metaBrutoDiario * dias;
      const totalMetaLiquido = metaLiquidoDiario * dias;
      const diffBruto = totais.bruto - totalMetaBruto;
      const diffLiquido = totais.liquido - totalMetaLiquido;
      const percBruto = totalMetaBruto ? (diffBruto / totalMetaBruto) * 100 : 0;
      const percLiquido = totalMetaLiquido ? (diffLiquido / totalMetaLiquido) * 100 : 0;
      const resumoBrutoMeta = metaBrutoDiario ? `<small>${diffBruto >= 0 ? 'Acima' : 'Abaixo'} da meta (${percBruto.toFixed(2)}%, R$ ${Math.abs(diffBruto).toLocaleString('pt-BR')})</small>` : '';
      const resumoLiquidoMeta = metaLiquidoDiario ? `<small>${diffLiquido >= 0 ? 'Acima' : 'Abaixo'} da meta (${percLiquido.toFixed(2)}%, R$ ${Math.abs(diffLiquido).toLocaleString('pt-BR')})</small>` : '';
      
      resumoEl.classList.add('resumo-grid');
resumoEl.innerHTML = `
   <div class="resumo-card"><h4>Total Bruto</h4><p>R$ ${totais.bruto.toLocaleString('pt-BR')}</p>${resumoBrutoMeta}</div>
        <div class="resumo-card"><h4>Total L√≠quido</h4><p>R$ ${totais.liquido.toLocaleString('pt-BR')}</p>${resumoLiquidoMeta}</div>
        <div class="resumo-card"><h4>Total Vendido</h4><p>${totais.vendas}</p><button class="btn btn-secondary btn-sm" style="margin-top:0.5rem" onclick="mostrarDetalhesVendas()">Ver mais</button></div>
        <div class="resumo-card"><h4>Total Sobra Esperada</h4><p>R$ ${totais.sobra.toLocaleString('pt-BR')}</p><button class="btn btn-secondary btn-sm" style="margin-top:0.5rem" onclick="mostrarDetalhesSobra()">Ver mais</button></div>
        <div class="resumo-card"><h4>Total Saques</h4><p>R$ ${totalSaques.toLocaleString('pt-BR')}</p></div>
        <div class="resumo-card"><h4>Comiss√£o do M√™s</h4><p>R$ ${totalComissao.toLocaleString('pt-BR')}</p></div>
        <div class="resumo-card"><h4>Ticket M√©dio</h4><p>R$ ${ticket.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p></div>`;
    }

function mostrarDetalhesVendas(data = resumoSku) {
  if (!data || !Object.keys(data).length) {
    Swal.fire('Sem dados', 'N√£o h√° informa√ß√µes de vendas por SKU para o per√≠odo selecionado.', 'info');
    return;
  }

  const entries = Object.entries(data)
    .map(([sku, info]) => [sku, Number(info.vendas) || 0])
    .sort((a, b) => b[1] - a[1]);

  const total = entries.reduce((acc, [, v]) => acc + v, 0);

  let rows = '';
  for (const [sku, qtd] of entries) {
    rows += `
      <tr>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;"><strong>${sku}</strong></td>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;text-align:right;">${qtd}</td>
      </tr>`;
  }

  const html = `
    <div style="text-align:left; max-height:60vh; overflow:auto;">
      <table style="width:100%; border-collapse:collapse; font-size:14px;">
        <thead>
          <tr>
            <th style="text-align:left; padding:8px 10px; border-bottom:1px solid #ddd;">SKU</th>
            <th style="text-align:right; padding:8px 10px; border-bottom:1px solid #ddd;">Quantidade Vendida</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
        <tfoot>
          <tr>
            <td style="padding:10px; font-weight:600; border-top:2px solid #ddd;">Total</td>
            <td style="padding:10px; text-align:right; font-weight:600; border-top:2px solid #ddd;">${total}</td>
          </tr>
        </tfoot>
      </table>
    </div>`;

  Swal.fire({
    title: 'Vendas por SKU',
    html,
    width: '80%',
    confirmButtonText: 'Fechar'
  });
}

function mostrarDetalhesSobra(data = sobraPorSku) {
  if (!data || !Object.keys(data).length) {
    Swal.fire('Sem dados', 'N√£o h√° informa√ß√µes de sobra esperada por SKU para o per√≠odo selecionado.', 'info');
    return;
  }

  const fmtBRL = new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' });

  // entries = [['SKU1', 123.45], ...] ‚Äî garantindo n√∫mero v√°lido
  const entries = Object.entries(data)
    .map(([sku, v]) => [sku, Number(v) || 0])
    .sort((a, b) => b[1] - a[1]); // ordem decrescente por valor

  const total = entries.reduce((acc, [, v]) => acc + v, 0);

  // Monta tabela
  let rows = '';
  for (const [sku, valor] of entries) {
    rows += `
      <tr>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;"><strong>${sku}</strong></td>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;text-align:right;">${fmtBRL.format(valor)}</td>
      </tr>`;
  }

  const html = `
    <div style="text-align:left; max-height:60vh; overflow:auto;">
      <table style="width:100%; border-collapse:collapse; font-size:14px;">
        <thead>
          <tr>
            <th style="text-align:left; padding:8px 10px; border-bottom:1px solid #ddd;">SKU</th>
            <th style="text-align:right; padding:8px 10px; border-bottom:1px solid #ddd;">Sobra Esperada</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
        <tfoot>
          <tr>
            <td style="padding:10px; font-weight:600; border-top:2px solid #ddd;">Total</td>
            <td style="padding:10px; text-align:right; font-weight:600; border-top:2px solid #ddd;">${fmtBRL.format(total)}</td>
          </tr>
        </tfoot>
      </table>
    </div>`;

  Swal.fire({
    title: 'Sobra Esperada por SKU',
    html,
    width: 720,
    confirmButtonText: 'OK'
  });
}

     function exportarAcompanhamentoExcel() {
      if (!dadosAcompanhamento.length) return;

      const mediaSaques = totalSaquesAcompanhamento / (dadosAcompanhamento.length || 1);
      const sheetData = dadosAcompanhamento.map(d => ({
        Data: d.data,
        Bruto: d.bruto,
        Liquido: d.liquido,
        Vendas: d.vendas,
        SobraEsperada: d.sobra,
        SobraReal: d.sobra - mediaSaques
      }));

      const wsVendas = XLSX.utils.json_to_sheet(sheetData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, wsVendas, 'Vendas');

      const totais = dadosAcompanhamento.reduce((acc, item) => {
        acc.bruto += item.bruto || 0;
        acc.liquido += item.liquido || 0;
        acc.vendas += item.vendas || 0;
        acc.sobra += item.sobra || 0;
        return acc;
      }, { bruto: 0, liquido: 0, vendas: 0, sobra: 0 });
      const sobraRealTotal = totais.sobra - totalSaquesAcompanhamento;

      const entries = Object.entries(sobraPorSku || {});
      let maiorEntrada = ['', 0], menorEntrada = ['', 0], prejuizo = ['', 0];
      if (entries.length) {
        maiorEntrada = entries.reduce((a,b)=>b[1]>a[1]?b:a, entries[0]);
        menorEntrada = entries.reduce((a,b)=>b[1]<a[1]?b:a, entries[0]);
        const negativos = entries.filter(([,v])=>v<0);
        if (negativos.length) prejuizo = negativos.reduce((a,b)=>b[1]<a[1]?b:a, negativos[0]);
      }

      const resumo = [
        { Campo: 'Sobra Esperada Total', Valor: totais.sobra },
        { Campo: 'Sobra Real Total', Valor: sobraRealTotal },
        { Campo: 'Produto Maior Entrada', SKU: maiorEntrada[0], Valor: maiorEntrada[1] },
        { Campo: 'Produto Menor Entrada', SKU: menorEntrada[0], Valor: menorEntrada[1] }
      ];
      if (prejuizo[0]) resumo.push({ Campo: 'Produto Preju√≠zo', SKU: prejuizo[0], Valor: prejuizo[1] });

      const resumoSkus = Object.entries(resumoSku || {})
        .map(([sku, info]) => ({
          SKU: sku,
          Vendas: info.vendas,
          SobraEsperada: info.sobra,
          Liquido: info.liquido
        }))
        .sort((a, b) => b.Vendas - a.Vendas);

      const wsResumo = XLSX.utils.json_to_sheet(resumo);
      XLSX.utils.sheet_add_aoa(wsResumo, [[]], { origin: -1 });
      XLSX.utils.sheet_add_json(wsResumo, resumoSkus, { origin: -1 });
      XLSX.utils.book_append_sheet(wb, wsResumo, 'Resumo');

      XLSX.writeFile(wb, 'acompanhamento.xlsx');
    }

    function exportarAcompanhamentoPDF() {
      const element = document.getElementById('areaImpressao');
      if (!element) return;
      const opt = { margin: 1, filename: 'acompanhamento.pdf', image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2 }, jsPDF: { unit: 'cm', format: 'a4', orientation: 'portrait' } };
      html2pdf().set(opt).from(element).save();
    }

    function printAcompanhamento() {
 const element = document.getElementById('areaImpressao');
      if (!element) return;
      const printWindow = window.open('', '', 'width=900,height=650');
      printWindow.document.write(`
        <html>
          <head>
            <title>Imprimir Acompanhamento</title>
            <link rel="stylesheet" href="css/styles.css?v=20240826">
          </head>
          <body>
            ${element.innerHTML}
          </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.focus();
      printWindow.print();
      printWindow.close();
    }
  
    function salvarMetasAcompanhamento() {
      const bruto = parseFloat(document.getElementById('metaBrutoDiario').value) || 0;
      const liquido = parseFloat(document.getElementById('metaLiquidoDiario').value) || 0;
      localStorage.setItem('metaBrutoDiario', bruto);
      localStorage.setItem('metaLiquidoDiario', liquido);
      carregarAcompanhamento();
    }

function aplicarEstiloCritico() {
  const linhas = document.querySelectorAll("#resultado tbody tr");

  linhas.forEach(linha => {
    const statusEl = linha.querySelector(".status-only");
    if (!statusEl) return;

    const status = statusEl.textContent.trim().toLowerCase();

    if (status === "cr√≠tico") {
      linha.style.backgroundColor = "#ffebee"; // fundo vermelho claro
      linha.style.color = "#b71c1c";            // texto vermelho escuro
      linha.style.fontWeight = "bold";
    } else {
      // Remove estilo se n√£o for cr√≠tico (√∫til em reaplica√ß√µes de filtro)
      linha.style.backgroundColor = "";
      linha.style.color = "";
      linha.style.fontWeight = "";
    }
  });
}
 window.toggleInfoFaturamento = function() {
    const card = document.getElementById('infoFaturamento');
    if (card) {
      card.classList.toggle('hidden');
    }
  };


function filtrarPorSKU() {
  const tipoFiltro = document.getElementById('tipoFiltro').value;
  const textoSKU = document.getElementById('filtroSKU').value.trim().toLowerCase();
  const filtroStatus = document.getElementById('filtroStatus').value.toLowerCase();

  const linhas = document.querySelectorAll("#resultado tbody tr");

  linhas.forEach(linha => {
    const sku = linha.children[1].textContent.toLowerCase();
    const status = linha.querySelector('.status-only')?.dataset.status.toLowerCase() || '';

    let corresponde = false;

    if (textoSKU === '') {
      corresponde = true;
    } else if (tipoFiltro === 'exata') {
      corresponde = sku === textoSKU;
    } else if (tipoFiltro === 'comeca') {
      corresponde = sku.startsWith(textoSKU);
    } else {
      corresponde = sku.includes(textoSKU);
    }

    const statusCorresponde = !filtroStatus || status === filtroStatus;

  linha.style.display = corresponde && statusCorresponde ? '' : 'none';
  });
}

async function verificarGestorFinanceiro() {
  try {
    const snap = await db.collection('usuarios')
      .where('responsavelFinanceiroEmail', '==', usuarioLogado.email)
      .limit(1)
      .get();
    if (!snap.empty) {
      const btn = document.getElementById('btnAcompanhamentoGestor');
      if (btn) btn.classList.remove('hidden');
    }
  } catch (e) {
    console.error('Erro ao verificar gestor financeiro', e);
  }
}

async function carregarAcompanhamentoGestor() {
  const pedidosBody = document.querySelector('#tabelaPedidosCriticosGestor tbody');
  if (pedidosBody) pedidosBody.innerHTML = '';

  try {
    const usuariosSnap = await db.collection('usuarios')
      .where('responsavelFinanceiroEmail', '==', usuarioLogado.email)
      .get();
    const usuarios = [];
    usuariosSnap.forEach(doc => usuarios.push({ uid: doc.id, ...doc.data() }));

    const selectUsuario = document.getElementById('filtroUsuarioGestor');
    if (selectUsuario && selectUsuario.options.length <= 1) {
      usuarios.forEach(u => {
        const opt = document.createElement('option');
        opt.value = u.uid;
        opt.textContent = u.nome || u.email || u.uid;
        selectUsuario.appendChild(opt);
      });
    }

    const filtroUsuario = selectUsuario ? selectUsuario.value : '';
    const tipoData = document.getElementById('filtroDataTipo')?.value || 'mes';
    let inicio = null, fim = null;
    if (tipoData === 'dia') {
      const dia = document.getElementById('filtroDiaGestor')?.value;
      if (dia) { inicio = dia; fim = dia; }
    } else if (tipoData === 'periodo') {
      inicio = document.getElementById('filtroInicioGestor')?.value;
      fim = document.getElementById('filtroFimGestor')?.value;
    } else {
      const mes = document.getElementById('filtroMesGestor')?.value;
      if (mes) {
        inicio = mes + '-01';
        const [ano, m] = mes.split('-');
        const ultimoDia = new Date(ano, m, 0).getDate();
        fim = `${mes}-${String(ultimoDia).padStart(2,'0')}`;
      }
    }

    const pedidosErrados = [];

    for (const u of usuarios) {
      if (filtroUsuario && u.uid !== filtroUsuario) continue;

      const errSnap = await db.collection('uid').doc(u.uid).collection('pedidosErrados').get();
      errSnap.forEach(e => {
        const d = e.data();
        const dataPedido = d.dia || d.data || d.dataPedido;
        if (inicio && fim && dataPedido && (dataPedido < inicio || dataPedido > fim)) return;
        pedidosErrados.push({ usuario: u.nome || u.email || u.uid, ...d });
      });
    }

    if (pedidosBody) {
      if (!pedidosErrados.length) {
        pedidosBody.innerHTML = '<tr><td colspan="6" class="text-center text-gray-500">Sem pedidos registrados</td></tr>';
      } else {
        pedidosErrados.forEach(p => {
          const dataPedido = p.dia || p.dataPedido || p.data || '';
          const pedido = p.pedido || p.numeroPedido || p.id || '';
          const sku = p.sku || '';
          const qtd = p.quantidade || p.qtd || 0;
          const esp = Number(p.sobraEsperada || p.metaEsperada || 0);
          const real = Number(p.sobraReal || p.totalLiquido || 0);
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${dataPedido}</td><td>${pedido}</td><td>${sku}</td><td>${qtd}</td><td>R$ ${esp.toFixed(2)}</td><td>R$ ${real.toFixed(2)}</td>`;
          pedidosBody.appendChild(tr);
        });
      }
    }
  } catch (e) {
    console.error('Erro ao carregar acompanhamento do gestor', e);
    if (pedidosBody) pedidosBody.innerHTML = '<tr><td colspan="6" class="text-red-500">Erro ao carregar dados</td></tr>';
  }
}

function atualizarTipoFiltroGestor() {
  const tipo = document.getElementById('filtroDataTipo')?.value;
  const mesEl = document.getElementById('filtroMesGestor');
  const diaEl = document.getElementById('filtroDiaGestor');
  const periodoEl = document.getElementById('filtroPeriodoGestor');
  mesEl?.classList.add('hidden');
  diaEl?.classList.add('hidden');
  periodoEl?.classList.add('hidden');
  if (tipo === 'dia') diaEl?.classList.remove('hidden');
  else if (tipo === 'periodo') periodoEl?.classList.remove('hidden');
  else mesEl?.classList.remove('hidden');
}

async function atualizarResponsavelFinanceiro(btn) {
  const botao = btn || document.getElementById('btnAtualizarRespFin');
  if (botao) toggleLoading(botao, 'Atualizar Respons√°vel');
  try {
    const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
    const dadosUsuario = usuarioDoc.data() || {};
    const respEmail = (dadosUsuario.responsavelFinanceiroEmail || '').trim();
    if (!respEmail) {
      alert('Nenhum respons√°vel financeiro configurado.');
      return;
    }
    const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
    let respDoc;
    if (respSnap.empty) {
      const altSnap = await db.collection('uid').where('email', '==', respEmail).limit(1).get();
      if (altSnap.empty) {
        alert('Respons√°vel financeiro n√£o encontrado.');
        return;
      }
      respDoc = altSnap.docs[0];
    } else {
      respDoc = respSnap.docs[0];
    }
    const respData = respDoc.data() || {};
    const responsavelUid = respData.uid || respDoc.id;
    const baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
    const pass = getPassphrase() || usuarioLogado.uid;
    const filtroMes = document.getElementById('filtroMesAcompanhamento')?.value || document.getElementById('filtroMesRegistro')?.value;
    const { decryptString, encryptString } = await import('./crypto.js');
    const snap = await db.collection('uid').doc(usuarioLogado.uid).collection('faturamento').get();
    for (const doc of snap.docs) {
      const dia = doc.id;
      if (filtroMes) {
        const [anoFiltro, mesFiltro] = filtroMes.split('-');
        const [ano, mes] = dia.split('-');
        if (ano !== anoFiltro || mes !== mesFiltro) continue;
      }
      let resumo = doc.data();
      if (resumo.encrypted) {
        try {
          resumo = JSON.parse(await decryptString(resumo.encrypted, pass));
        } catch (e) {
          console.error('Erro ao descriptografar faturamento', e);
          continue;
        }
      }
      const resumoResp = await baseResp.collection('faturamento').doc(dia).get();
      if (!resumoResp.exists) {
        const encResumo = await encryptString(JSON.stringify(resumo), respEmail);
        await baseResp.collection('faturamento').doc(dia).set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
      }
      const lojasSnap = await db.collection(`uid/${usuarioLogado.uid}/faturamento/${dia}/lojas`).get();
      for (const lojaDoc of lojasSnap.docs) {
        const loja = lojaDoc.id;
        const destinoDoc = await baseResp.collection('faturamento').doc(dia).collection('lojas').doc(loja).get();
        if (destinoDoc.exists) continue;
        let dadosLoja = lojaDoc.data();
        if (dadosLoja.encrypted) {
          try {
            dadosLoja = JSON.parse(await decryptString(dadosLoja.encrypted, pass));
          } catch (e) {
            console.error('Erro ao descriptografar faturamento', e);
            continue;
          }
      }
      const encLoja = await encryptString(JSON.stringify(dadosLoja), respEmail);
      await baseResp
        .collection('faturamento')
        .doc(dia)
        .collection('lojas')
        .doc(loja)
        .set({ encrypted: encLoja, uid: usuarioLogado.uid });
      }
    }

    // Copiar SKUs vendidos para o respons√°vel financeiro
    const skusSnap = await db.collection('uid').doc(usuarioLogado.uid).collection('skusVendidos').get();
    for (const doc of skusSnap.docs) {
      const dia = doc.id;
      if (filtroMes) {
        const [anoFiltro, mesFiltro] = filtroMes.split('-');
        const [ano, mes] = dia.split('-');
        if (ano !== anoFiltro || mes !== mesFiltro) continue;
      }
      const listaSnap = await db.collection(`uid/${usuarioLogado.uid}/skusVendidos/${dia}/lista`).get();
      if (listaSnap.empty) continue;
      await baseResp.collection('skusVendidos').doc(dia).set({ data: dia, uid: usuarioLogado.uid }, { merge: true });
      for (const skuDoc of listaSnap.docs) {
        const dadosSku = skuDoc.data();
        const payload = {
          sku: dadosSku.sku || skuDoc.id,
          total: dadosSku.total || 0,
          valorLiquido: dadosSku.valorLiquido || 0,
          data: dia,
          loja: dadosSku.loja || null,
          uid: usuarioLogado.uid
        };
        const dadoSalvar = respEmail
          ? { encrypted: await encryptString(JSON.stringify(payload), respEmail), uid: usuarioLogado.uid }
          : payload;
        await baseResp
          .collection('skusVendidos')
          .doc(dia)
          .collection('lista')
          .doc(skuDoc.id)
          .set(dadoSalvar);
      }
    }

    alert('Dados enviados ao respons√°vel financeiro.');
  } catch (e) {
    console.error('Erro ao atualizar respons√°vel financeiro', e);
    alert('Erro ao atualizar respons√°vel financeiro.');
  } finally {
    if (botao) toggleLoading(botao, 'Atualizar Respons√°vel');
  }
}

window.carregarRegistrosFaturamento = carregarRegistrosFaturamento;
window.carregarControleVendas = carregarControleVendas;
window.carregarSobras = carregarSobras;
window.carregarPrevisao = carregarPrevisao;
window.gerarPrevisao = gerarPrevisao;
window.renderizarPrevisao = renderizarPrevisao;
window.carregarAcompanhamento = carregarAcompanhamento;
window.carregarAcompanhamentoGestor = carregarAcompanhamentoGestor;
window.verificarGestorFinanceiro = verificarGestorFinanceiro;
window.exportarAcompanhamentoExcel = exportarAcompanhamentoExcel;
window.exportarAcompanhamentoPDF = exportarAcompanhamentoPDF;
window.printAcompanhamento = printAcompanhamento;
  window.salvarMetasAcompanhamento = salvarMetasAcompanhamento;
window.atualizarResponsavelFinanceiro = atualizarResponsavelFinanceiro;
window.exportarVendasMes = exportarVendasMes;
window.mostrarDetalhesVendas = mostrarDetalhesVendas;
window.mostrarDetalhesSobra = mostrarDetalhesSobra;
window.mostrarDetalhesFaturamento = mostrarDetalhesFaturamento;
window.excluirFaturamento = excluirFaturamento;
window.analisarSobrasIA = analisarSobrasIA;
window.exportarCSV = exportarCSV;
window.exportarJSON = exportarJSON;
window.verificarConexao = verificarConexao;
window.editarMeta = editarMeta;
window.excluirMeta = excluirMeta;
window.atualizarTipoFiltroGestor = atualizarTipoFiltroGestor;
  window.analisarTendenciasIA = analisarTendenciasIA;
  window.atualizarStatusLogistica = atualizarStatusLogistica;
window.atualizarRastreio = atualizarRastreio;
window.atualizarChecklist = atualizarChecklist;
window.aplicarFiltroLogistica = aplicarFiltroLogistica;
  window.processarPlanilha = processarPlanilha;
window.toggleExportMenu = toggleExportMenu;

</script>
<script src="shared.js"></script>
<!-- Outras bibliotecas (como XLSX) -->
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

</body>
</html>
